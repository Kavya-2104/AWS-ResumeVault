{"ast":null,"code":"import BigInteger from './BigInteger/BigInteger.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n/**\n * Tests if a hex string has it most significant bit set (case-insensitive regex)\n */\nconst HEX_MSB_REGEX = /^[89a-f]/i;\n/**\n * Returns an unambiguous, even-length hex string of the two's complement encoding of an integer.\n *\n * It is compatible with the hex encoding of Java's BigInteger's toByteArray(), wich returns a\n * byte array containing the two's-complement representation of a BigInteger. The array contains\n * the minimum number of bytes required to represent the BigInteger, including at least one sign bit.\n *\n * Examples showing how ambiguity is avoided by left padding with:\n * \t\"00\" (for positive values where the most-significant-bit is set)\n *  \"FF\" (for negative values where the most-significant-bit is set)\n *\n * padHex(bigInteger.fromInt(-236))  === \"FF14\"\n * padHex(bigInteger.fromInt(20))    === \"14\"\n *\n * padHex(bigInteger.fromInt(-200))  === \"FF38\"\n * padHex(bigInteger.fromInt(56))    === \"38\"\n *\n * padHex(bigInteger.fromInt(-20))   === \"EC\"\n * padHex(bigInteger.fromInt(236))   === \"00EC\"\n *\n * padHex(bigInteger.fromInt(-56))   === \"C8\"\n * padHex(bigInteger.fromInt(200))   === \"00C8\"\n *\n * @param {AuthBigInteger} bigInt Number to encode.\n * @returns {String} even-length hex string of the two's complement encoding.\n */\nconst getPaddedHex = bigInt => {\n  if (!(bigInt instanceof BigInteger)) {\n    throw new Error('Not a BigInteger');\n  }\n  const isNegative = bigInt.compareTo(BigInteger.ZERO) < 0;\n  /* Get a hex string for abs(bigInt) */\n  let hexStr = bigInt.abs().toString(16);\n  /* Pad hex to even length if needed */\n  hexStr = hexStr.length % 2 !== 0 ? `0${hexStr}` : hexStr;\n  /* Prepend \"00\" if the most significant bit is set */\n  hexStr = HEX_MSB_REGEX.test(hexStr) ? `00${hexStr}` : hexStr;\n  if (isNegative) {\n    /* Flip the bits of the representation */\n    const invertedNibbles = hexStr.split('').map(x => {\n      const invertedNibble = ~parseInt(x, 16) & 0xf;\n      return '0123456789ABCDEF'.charAt(invertedNibble);\n    }).join('');\n    /* After flipping the bits, add one to get the 2's complement representation */\n    const flippedBitsBI = new BigInteger(invertedNibbles, 16).add(BigInteger.ONE);\n    hexStr = flippedBitsBI.toString(16);\n    /*\n    For hex strings starting with 'FF8', 'FF' can be dropped, e.g. 0xFFFF80=0xFF80=0x80=-128\n     Any sequence of '1' bits on the left can always be substituted with a single '1' bit\n    without changing the represented value.\n     This only happens in the case when the input is 80...00\n    */\n    if (hexStr.toUpperCase().startsWith('FF8')) {\n      hexStr = hexStr.substring(2);\n    }\n  }\n  return hexStr;\n};\nexport { getPaddedHex };","map":{"version":3,"names":["HEX_MSB_REGEX","getPaddedHex","bigInt","BigInteger","Error","isNegative","compareTo","ZERO","hexStr","abs","toString","length","test","invertedNibbles","split","map","x","invertedNibble","parseInt","charAt","join","flippedBitsBI","add","ONE","toUpperCase","startsWith","substring"],"sources":["E:\\CSC-PROJECT\\amplify-react-app\\node_modules\\@aws-amplify\\auth\\src\\providers\\cognito\\utils\\srp\\getPaddedHex.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { BigInteger } from './BigInteger';\n/**\n * Tests if a hex string has it most significant bit set (case-insensitive regex)\n */\nconst HEX_MSB_REGEX = /^[89a-f]/i;\n/**\n * Returns an unambiguous, even-length hex string of the two's complement encoding of an integer.\n *\n * It is compatible with the hex encoding of Java's BigInteger's toByteArray(), wich returns a\n * byte array containing the two's-complement representation of a BigInteger. The array contains\n * the minimum number of bytes required to represent the BigInteger, including at least one sign bit.\n *\n * Examples showing how ambiguity is avoided by left padding with:\n * \t\"00\" (for positive values where the most-significant-bit is set)\n *  \"FF\" (for negative values where the most-significant-bit is set)\n *\n * padHex(bigInteger.fromInt(-236))  === \"FF14\"\n * padHex(bigInteger.fromInt(20))    === \"14\"\n *\n * padHex(bigInteger.fromInt(-200))  === \"FF38\"\n * padHex(bigInteger.fromInt(56))    === \"38\"\n *\n * padHex(bigInteger.fromInt(-20))   === \"EC\"\n * padHex(bigInteger.fromInt(236))   === \"00EC\"\n *\n * padHex(bigInteger.fromInt(-56))   === \"C8\"\n * padHex(bigInteger.fromInt(200))   === \"00C8\"\n *\n * @param {AuthBigInteger} bigInt Number to encode.\n * @returns {String} even-length hex string of the two's complement encoding.\n */\nexport const getPaddedHex = (bigInt) => {\n    if (!(bigInt instanceof BigInteger)) {\n        throw new Error('Not a BigInteger');\n    }\n    const isNegative = bigInt.compareTo(BigInteger.ZERO) < 0;\n    /* Get a hex string for abs(bigInt) */\n    let hexStr = bigInt.abs().toString(16);\n    /* Pad hex to even length if needed */\n    hexStr = hexStr.length % 2 !== 0 ? `0${hexStr}` : hexStr;\n    /* Prepend \"00\" if the most significant bit is set */\n    hexStr = HEX_MSB_REGEX.test(hexStr) ? `00${hexStr}` : hexStr;\n    if (isNegative) {\n        /* Flip the bits of the representation */\n        const invertedNibbles = hexStr\n            .split('')\n            .map((x) => {\n            const invertedNibble = ~parseInt(x, 16) & 0xf;\n            return '0123456789ABCDEF'.charAt(invertedNibble);\n        })\n            .join('');\n        /* After flipping the bits, add one to get the 2's complement representation */\n        const flippedBitsBI = new BigInteger(invertedNibbles, 16).add(BigInteger.ONE);\n        hexStr = flippedBitsBI.toString(16);\n        /*\n        For hex strings starting with 'FF8', 'FF' can be dropped, e.g. 0xFFFF80=0xFF80=0x80=-128\n\n        Any sequence of '1' bits on the left can always be substituted with a single '1' bit\n        without changing the represented value.\n\n        This only happens in the case when the input is 80...00\n        */\n        if (hexStr.toUpperCase().startsWith('FF8')) {\n            hexStr = hexStr.substring(2);\n        }\n    }\n    return hexStr;\n};\n"],"mappings":";;AAAA;AACA;AAEA;AACA;AACA;AACA,MAAMA,aAAa,GAAG,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAACC,YAAY,GAAIC,MAAM,IAAK;EACpC,IAAI,EAAEA,MAAM,YAAYC,UAAU,CAAC,EAAE;IACjC,MAAM,IAAIC,KAAK,CAAC,kBAAkB,CAAC;EAC3C;EACI,MAAMC,UAAU,GAAGH,MAAM,CAACI,SAAS,CAACH,UAAU,CAACI,IAAI,CAAC,GAAG,CAAC;EAC5D;EACI,IAAIC,MAAM,GAAGN,MAAM,CAACO,GAAG,EAAE,CAACC,QAAQ,CAAC,EAAE,CAAC;EAC1C;EACIF,MAAM,GAAGA,MAAM,CAACG,MAAM,GAAG,CAAC,KAAK,CAAC,GAAI,IAAGH,MAAO,EAAC,GAAGA,MAAM;EAC5D;EACIA,MAAM,GAAGR,aAAa,CAACY,IAAI,CAACJ,MAAM,CAAC,GAAI,KAAIA,MAAO,EAAC,GAAGA,MAAM;EAC5D,IAAIH,UAAU,EAAE;IACpB;IACQ,MAAMQ,eAAe,GAAGL,MAAM,CACzBM,KAAK,CAAC,EAAE,CAAC,CACTC,GAAG,CAAEC,CAAC,IAAK;MACZ,MAAMC,cAAc,GAAG,CAACC,QAAQ,CAACF,CAAC,EAAE,EAAE,CAAC,GAAG,GAAG;MAC7C,OAAO,kBAAkB,CAACG,MAAM,CAACF,cAAc,CAAC;IAC5D,CAAS,CAAC,CACGG,IAAI,CAAC,EAAE,CAAC;IACrB;IACQ,MAAMC,aAAa,GAAG,IAAIlB,UAAU,CAACU,eAAe,EAAE,EAAE,CAAC,CAACS,GAAG,CAACnB,UAAU,CAACoB,GAAG,CAAC;IAC7Ef,MAAM,GAAGa,aAAa,CAACX,QAAQ,CAAC,EAAE,CAAC;IAC3C;AACA;AACA;AACA;AACA;AACA;IAGQ,IAAIF,MAAM,CAACgB,WAAW,EAAE,CAACC,UAAU,CAAC,KAAK,CAAC,EAAE;MACxCjB,MAAM,GAAGA,MAAM,CAACkB,SAAS,CAAC,CAAC,CAAC;IACxC;EACA;EACI,OAAOlB,MAAM;AACjB"},"metadata":{},"sourceType":"module","externalDependencies":[]}