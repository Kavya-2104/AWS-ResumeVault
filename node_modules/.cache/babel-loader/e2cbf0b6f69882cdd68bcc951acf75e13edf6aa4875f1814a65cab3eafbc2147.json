{"ast":null,"code":"import { StorageError } from '../../../../../errors/StorageError.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n/**\n * Maps an object to a new object using the provided instructions.\n * The instructions are a map of the returning mapped object's property names to a single instruction of how to map the\n * value from the original object to the new object. There are two types of instructions:\n *\n * 1. A string representing the property name of the original object to map to the new object. The value mapped from\n * the original object will be the same as the value in the new object, and it can ONLY be string.\n *\n * 2. An array of two elements. The first element is the property name of the original object to map to the new object.\n * The second element is a function that takes the value from the original object and returns the value to be mapped to\n * the new object. The function can return any type.\n *\n * Example:\n * ```typescript\n * const input = {\n *   Foo: 'foo',\n *   BarList: [{value: 'bar1'}, {value: 'bar2'}]\n * }\n * const output = map(input, {\n *   someFoo: 'Foo',\n *   bar: ['BarList', (barList) => barList.map(bar => bar.value)]\n *   baz: 'Baz' // Baz does not exist in input, so it will not be in the output.\n * });\n * // output = { someFoo: 'foo', bar: ['bar1', 'bar2'] }\n * ```\n *\n * @param obj The object containing the data to compose mapped object.\n * @param instructions The instructions mapping the object values to the new object.\n * @returns A new object with the mapped values.\n *\n * @internal\n */\nconst map = (obj, instructions) => {\n  const result = {};\n  for (const [key, instruction] of Object.entries(instructions)) {\n    const [accessor, deserializer] = Array.isArray(instruction) ? instruction : [instruction];\n    if (obj.hasOwnProperty(accessor)) {\n      result[key] = deserializer ? deserializer(obj[accessor]) : String(obj[accessor]);\n    }\n  }\n  return result;\n};\n/**\n * Deserializes a string to a number. Returns undefined if input is undefined.\n *\n * @internal\n */\nconst deserializeNumber = value => value ? Number(value) : undefined;\n/**\n * Deserializes a string to a boolean. Returns undefined if input is undefined. Returns true if input is 'true',\n * otherwise false.\n *\n * @internal\n */\nconst deserializeBoolean = value => {\n  return value ? value === 'true' : undefined;\n};\n/**\n * Deserializes a string to a Date. Returns undefined if input is undefined.\n * It supports epoch timestamp; rfc3339(cannot have a UTC, fractional precision supported); rfc7231(section 7.1.1.1)\n *\n * @see https://www.epoch101.com/\n * @see https://datatracker.ietf.org/doc/html/rfc3339.html#section-5.6\n * @see https://datatracker.ietf.org/doc/html/rfc7231.html#section-7.1.1.1\n *\n * @note For bundle size consideration, we use Date constructor to parse the timestamp string. There might be slight\n * difference among browsers.\n *\n * @internal\n */\nconst deserializeTimestamp = value => {\n  return value ? new Date(value) : undefined;\n};\n/**\n * Function that makes sure the deserializer receives non-empty array.\n *\n * @internal\n */\nconst emptyArrayGuard = (value, deserializer) => {\n  if (value === '') {\n    return [];\n  }\n  const valueArray = (Array.isArray(value) ? value : [value]).filter(e => e != null);\n  return deserializer(valueArray);\n};\n/**\n * @internal\n */\nconst deserializeMetadata = headers => {\n  const objectMetadataHeaderPrefix = 'x-amz-meta-';\n  const deserialized = Object.keys(headers).filter(header => header.startsWith(objectMetadataHeaderPrefix)).reduce((acc, header) => {\n    acc[header.replace(objectMetadataHeaderPrefix, '')] = headers[header];\n    return acc;\n  }, {});\n  return Object.keys(deserialized).length > 0 ? deserialized : undefined;\n};\n/**\n * Internal-only method to create a new StorageError from a service error.\n *\n * @internal\n */\nconst buildStorageServiceError = (error, statusCode) => {\n  const storageError = new StorageError({\n    name: error.name,\n    message: error.message\n  });\n  if (statusCode === 404) {\n    storageError.recoverySuggestion = 'Please add the object with this key to the bucket as the key is not found.';\n  }\n  return storageError;\n};\nexport { buildStorageServiceError, deserializeBoolean, deserializeMetadata, deserializeNumber, deserializeTimestamp, emptyArrayGuard, map };","map":{"version":3,"names":["map","obj","instructions","result","key","instruction","Object","entries","accessor","deserializer","Array","isArray","hasOwnProperty","String","deserializeNumber","value","Number","undefined","deserializeBoolean","deserializeTimestamp","Date","emptyArrayGuard","valueArray","filter","e","deserializeMetadata","headers","objectMetadataHeaderPrefix","deserialized","keys","header","startsWith","reduce","acc","replace","length","buildStorageServiceError","error","statusCode","storageError","StorageError","name","message","recoverySuggestion"],"sources":["E:\\CSC-PROJECT\\amplify-react-app\\node_modules\\@aws-amplify\\storage\\src\\providers\\s3\\utils\\client\\utils\\deserializeHelpers.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { StorageError } from '../../../../../errors/StorageError';\n/**\n * Maps an object to a new object using the provided instructions.\n * The instructions are a map of the returning mapped object's property names to a single instruction of how to map the\n * value from the original object to the new object. There are two types of instructions:\n *\n * 1. A string representing the property name of the original object to map to the new object. The value mapped from\n * the original object will be the same as the value in the new object, and it can ONLY be string.\n *\n * 2. An array of two elements. The first element is the property name of the original object to map to the new object.\n * The second element is a function that takes the value from the original object and returns the value to be mapped to\n * the new object. The function can return any type.\n *\n * Example:\n * ```typescript\n * const input = {\n *   Foo: 'foo',\n *   BarList: [{value: 'bar1'}, {value: 'bar2'}]\n * }\n * const output = map(input, {\n *   someFoo: 'Foo',\n *   bar: ['BarList', (barList) => barList.map(bar => bar.value)]\n *   baz: 'Baz' // Baz does not exist in input, so it will not be in the output.\n * });\n * // output = { someFoo: 'foo', bar: ['bar1', 'bar2'] }\n * ```\n *\n * @param obj The object containing the data to compose mapped object.\n * @param instructions The instructions mapping the object values to the new object.\n * @returns A new object with the mapped values.\n *\n * @internal\n */\nexport const map = (obj, instructions) => {\n    const result = {};\n    for (const [key, instruction] of Object.entries(instructions)) {\n        const [accessor, deserializer] = Array.isArray(instruction)\n            ? instruction\n            : [instruction];\n        if (obj.hasOwnProperty(accessor)) {\n            result[key] = deserializer\n                ? deserializer(obj[accessor])\n                : String(obj[accessor]);\n        }\n    }\n    return result;\n};\n/**\n * Deserializes a string to a number. Returns undefined if input is undefined.\n *\n * @internal\n */\nexport const deserializeNumber = (value) => value ? Number(value) : undefined;\n/**\n * Deserializes a string to a boolean. Returns undefined if input is undefined. Returns true if input is 'true',\n * otherwise false.\n *\n * @internal\n */\nexport const deserializeBoolean = (value) => {\n    return value ? value === 'true' : undefined;\n};\n/**\n * Deserializes a string to a Date. Returns undefined if input is undefined.\n * It supports epoch timestamp; rfc3339(cannot have a UTC, fractional precision supported); rfc7231(section 7.1.1.1)\n *\n * @see https://www.epoch101.com/\n * @see https://datatracker.ietf.org/doc/html/rfc3339.html#section-5.6\n * @see https://datatracker.ietf.org/doc/html/rfc7231.html#section-7.1.1.1\n *\n * @note For bundle size consideration, we use Date constructor to parse the timestamp string. There might be slight\n * difference among browsers.\n *\n * @internal\n */\nexport const deserializeTimestamp = (value) => {\n    return value ? new Date(value) : undefined;\n};\n/**\n * Function that makes sure the deserializer receives non-empty array.\n *\n * @internal\n */\nexport const emptyArrayGuard = (value, deserializer) => {\n    if (value === '') {\n        return [];\n    }\n    const valueArray = (Array.isArray(value) ? value : [value]).filter(e => e != null);\n    return deserializer(valueArray);\n};\n/**\n * @internal\n */\nexport const deserializeMetadata = (headers) => {\n    const objectMetadataHeaderPrefix = 'x-amz-meta-';\n    const deserialized = Object.keys(headers)\n        .filter(header => header.startsWith(objectMetadataHeaderPrefix))\n        .reduce((acc, header) => {\n        acc[header.replace(objectMetadataHeaderPrefix, '')] = headers[header];\n        return acc;\n    }, {});\n    return Object.keys(deserialized).length > 0 ? deserialized : undefined;\n};\n/**\n * Internal-only method to create a new StorageError from a service error.\n *\n * @internal\n */\nexport const buildStorageServiceError = (error, statusCode) => {\n    const storageError = new StorageError({\n        name: error.name,\n        message: error.message,\n    });\n    if (statusCode === 404) {\n        storageError.recoverySuggestion =\n            'Please add the object with this key to the bucket as the key is not found.';\n    }\n    return storageError;\n};\n"],"mappings":";;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAACA,GAAG,GAAGA,CAACC,GAAG,EAAEC,YAAY,KAAK;EACtC,MAAMC,MAAM,GAAG,EAAE;EACjB,KAAK,MAAM,CAACC,GAAG,EAAEC,WAAW,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACL,YAAY,CAAC,EAAE;IAC3D,MAAM,CAACM,QAAQ,EAAEC,YAAY,CAAC,GAAGC,KAAK,CAACC,OAAO,CAACN,WAAW,CAAC,GACrDA,WAAW,GACX,CAACA,WAAW,CAAC;IACnB,IAAIJ,GAAG,CAACW,cAAc,CAACJ,QAAQ,CAAC,EAAE;MAC9BL,MAAM,CAACC,GAAG,CAAC,GAAGK,YAAY,GACpBA,YAAY,CAACR,GAAG,CAACO,QAAQ,CAAC,CAAC,GAC3BK,MAAM,CAACZ,GAAG,CAACO,QAAQ,CAAC,CAAC;IACvC;EACA;EACI,OAAOL,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACY,MAACW,iBAAiB,GAAIC,KAAK,IAAKA,KAAK,GAAGC,MAAM,CAACD,KAAK,CAAC,GAAGE,SAAA;AACpE;AACA;AACA;AACA;AACA;AACA;AACY,MAACC,kBAAkB,GAAIH,KAAK,IAAK;EACzC,OAAOA,KAAK,GAAGA,KAAK,KAAK,MAAM,GAAGE,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAACE,oBAAoB,GAAIJ,KAAK,IAAK;EAC3C,OAAOA,KAAK,GAAG,IAAIK,IAAI,CAACL,KAAK,CAAC,GAAGE,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACY,MAACI,eAAe,GAAGA,CAACN,KAAK,EAAEN,YAAY,KAAK;EACpD,IAAIM,KAAK,KAAK,EAAE,EAAE;IACd,OAAO,EAAE;EACjB;EACI,MAAMO,UAAU,GAAG,CAACZ,KAAK,CAACC,OAAO,CAACI,KAAK,CAAC,GAAGA,KAAK,GAAG,CAACA,KAAK,CAAC,EAAEQ,MAAM,CAACC,CAAC,IAAIA,CAAC,IAAI,IAAI,CAAC;EAClF,OAAOf,YAAY,CAACa,UAAU,CAAC;AACnC;AACA;AACA;AACA;AACY,MAACG,mBAAmB,GAAIC,OAAO,IAAK;EAC5C,MAAMC,0BAA0B,GAAG,aAAa;EAChD,MAAMC,YAAY,GAAGtB,MAAM,CAACuB,IAAI,CAACH,OAAO,CAAC,CACpCH,MAAM,CAACO,MAAM,IAAIA,MAAM,CAACC,UAAU,CAACJ,0BAA0B,CAAC,CAAC,CAC/DK,MAAM,CAAC,CAACC,GAAG,EAAEH,MAAM,KAAK;IACzBG,GAAG,CAACH,MAAM,CAACI,OAAO,CAACP,0BAA0B,EAAE,EAAE,CAAC,CAAC,GAAGD,OAAO,CAACI,MAAM,CAAC;IACrE,OAAOG,GAAG;EAClB,CAAK,EAAE,EAAE,CAAC;EACN,OAAO3B,MAAM,CAACuB,IAAI,CAACD,YAAY,CAAC,CAACO,MAAM,GAAG,CAAC,GAAGP,YAAY,GAAGX,SAAS;AAC1E;AACA;AACA;AACA;AACA;AACA;AACY,MAACmB,wBAAwB,GAAGA,CAACC,KAAK,EAAEC,UAAU,KAAK;EAC3D,MAAMC,YAAY,GAAG,IAAIC,YAAY,CAAC;IAClCC,IAAI,EAAEJ,KAAK,CAACI,IAAI;IAChBC,OAAO,EAAEL,KAAK,CAACK;EACvB,CAAK,CAAC;EACF,IAAIJ,UAAU,KAAK,GAAG,EAAE;IACpBC,YAAY,CAACI,kBAAkB,GAC3B,4EAA4E;EACxF;EACI,OAAOJ,YAAY;AACvB"},"metadata":{},"sourceType":"module","externalDependencies":[]}