{"ast":null,"code":"import { Amplify, defaultStorage, Hub } from '@aws-amplify/core';\nimport { isBrowser, assertTokenProviderConfig, assertOAuthConfig, urlSafeEncode, AuthAction, AmplifyUrl, AMPLIFY_SYMBOL, USER_AGENT_HEADER, decodeJWT, urlSafeDecode } from '@aws-amplify/core/internals/utils';\nimport { cacheCognitoTokens } from '../tokenProvider/cacheTokens.mjs';\nimport '../utils/clients/CognitoIdentityProvider/index.mjs';\nimport { AuthError } from '../../../errors/AuthError.mjs';\nimport '../../../errors/constants.mjs';\nimport '../tokenProvider/errorHelpers.mjs';\nimport { cognitoUserPoolsTokenProvider } from '../tokenProvider/tokenProvider.mjs';\nimport { cognitoHostedUIIdentityProviderMap } from '../types/models.mjs';\nimport { DefaultOAuthStore } from '../utils/signInWithRedirectStore.mjs';\nimport { AuthErrorTypes } from '../../../types/Auth.mjs';\nimport { AuthErrorCodes } from '../../../common/AuthErrorStrings.mjs';\nimport { authErrorMessages } from '../../../Errors.mjs';\nimport { getAuthUserAgentValue } from '../../../utils/getAuthUserAgentValue.mjs';\nimport { openAuthSession } from '../../../utils/openAuthSession.mjs';\nimport { assertUserNotAuthenticated } from '../utils/signInHelpers.mjs';\nimport { generateCodeVerifier } from '../utils/oauth/generateCodeVerifier.mjs';\nimport { generateState } from '../utils/oauth/generateState.mjs';\nimport { getRedirectUrl } from '../utils/oauth/getRedirectUrl.mjs';\nimport { getCurrentUser } from './getCurrentUser.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n/**\n * Signs in a user with OAuth. Redirects the application to an Identity Provider.\n *\n * @param input - The SignInWithRedirectInput object, if empty it will redirect to Cognito HostedUI\n *\n * @throws AuthTokenConfigException - Thrown when the userpool config is invalid.\n * @throws OAuthNotConfigureException - Thrown when the oauth config is invalid.\n */\nasync function signInWithRedirect(input) {\n  const authConfig = Amplify.getConfig().Auth?.Cognito;\n  assertTokenProviderConfig(authConfig);\n  assertOAuthConfig(authConfig);\n  store.setAuthConfig(authConfig);\n  await assertUserNotAuthenticated();\n  let provider = 'COGNITO'; // Default\n  if (typeof input?.provider === 'string') {\n    provider = cognitoHostedUIIdentityProviderMap[input.provider];\n  } else if (input?.provider?.custom) {\n    provider = input.provider.custom;\n  }\n  return oauthSignIn({\n    oauthConfig: authConfig.loginWith.oauth,\n    clientId: authConfig.userPoolClientId,\n    provider,\n    customState: input?.customState,\n    preferPrivateSession: input?.options?.preferPrivateSession\n  });\n}\nconst store = new DefaultOAuthStore(defaultStorage);\nasync function oauthSignIn({\n  oauthConfig,\n  provider,\n  clientId,\n  customState,\n  preferPrivateSession\n}) {\n  const {\n    domain,\n    redirectSignIn,\n    responseType,\n    scopes\n  } = oauthConfig;\n  const randomState = generateState();\n  /* encodeURIComponent is not URL safe, use urlSafeEncode instead. Cognito\n  single-encodes/decodes url on first sign in and double-encodes/decodes url\n  when user already signed in. Using encodeURIComponent, Base32, Base64 add\n  characters % or = which on further encoding becomes unsafe. '=' create issue\n  for parsing query params.\n  Refer: https://github.com/aws-amplify/amplify-js/issues/5218 */\n  const state = customState ? `${randomState}-${urlSafeEncode(customState)}` : randomState;\n  const {\n    value,\n    method,\n    toCodeChallenge\n  } = generateCodeVerifier(128);\n  const redirectUri = getRedirectUrl(oauthConfig.redirectSignIn);\n  store.storeOAuthInFlight(true);\n  store.storeOAuthState(state);\n  store.storePKCE(value);\n  const queryString = Object.entries({\n    redirect_uri: redirectUri,\n    response_type: responseType,\n    client_id: clientId,\n    identity_provider: provider,\n    scope: scopes.join(' '),\n    state,\n    ...(responseType === 'code' && {\n      code_challenge: toCodeChallenge(),\n      code_challenge_method: method\n    })\n  }).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');\n  // TODO(v6): use URL object instead\n  const oAuthUrl = `https://${domain}/oauth2/authorize?${queryString}`;\n  const {\n    type,\n    error,\n    url\n  } = (await openAuthSession(oAuthUrl)) ?? {};\n  // This code will run in RN applications only as calling signInWithRedirect will\n  // resolve the promise.\n  if (type === 'success' && url) {\n    // ensure the code exchange completion resolves the signInWithRedirect\n    // returned promise in react-native\n    await handleAuthResponse({\n      currentUrl: url,\n      clientId,\n      domain,\n      redirectUri: redirectSignIn[0],\n      responseType,\n      userAgentValue: getAuthUserAgentValue(AuthAction.SignInWithRedirect),\n      preferPrivateSession\n    });\n  }\n  // This code will run in RN applications only as calling signInWithRedirect will\n  // resolve the promise.\n  if (type === 'error') {\n    await handleFailure(String(error));\n  }\n}\nasync function handleCodeFlow({\n  currentUrl,\n  userAgentValue,\n  clientId,\n  redirectUri,\n  domain,\n  preferPrivateSession\n}) {\n  /* Convert URL into an object with parameters as keys\n  { redirect_uri: 'http://localhost:3000/', response_type: 'code', ...} */\n  const url = new AmplifyUrl(currentUrl);\n  let validatedState;\n  try {\n    validatedState = await validateState(getStateFromURL(url));\n  } catch (err) {\n    invokeAndClearPromise();\n    // validateState method will always throw an AuthError when the state is not valid. The if statement is making TS happy.\n    if (err instanceof AuthError) {\n      await handleFailure(err.message);\n    }\n    return;\n  }\n  const code = url.searchParams.get('code');\n  if (!code) {\n    await store.clearOAuthData();\n    invokeAndClearPromise();\n    return;\n  }\n  const oAuthTokenEndpoint = 'https://' + domain + '/oauth2/token';\n  // TODO(v6): check hub events\n  // dispatchAuthEvent(\n  // \t'codeFlow',\n  // \t{},\n  // \t`Retrieving tokens from ${oAuthTokenEndpoint}`\n  // );\n  const codeVerifier = await store.loadPKCE();\n  const oAuthTokenBody = {\n    grant_type: 'authorization_code',\n    code,\n    client_id: clientId,\n    redirect_uri: redirectUri,\n    ...(codeVerifier ? {\n      code_verifier: codeVerifier\n    } : {})\n  };\n  const body = Object.entries(oAuthTokenBody).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');\n  const {\n    access_token,\n    refresh_token,\n    id_token,\n    error,\n    error_message,\n    token_type,\n    expires_in\n  } = await (await fetch(oAuthTokenEndpoint, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      [USER_AGENT_HEADER]: userAgentValue\n    },\n    body\n  })).json();\n  if (error) {\n    invokeAndClearPromise();\n    await handleFailure(error_message ?? error);\n  }\n  await store.clearOAuthInflightData();\n  const username = (access_token && decodeJWT(access_token).payload.username) ?? 'username';\n  await cacheCognitoTokens({\n    username,\n    AccessToken: access_token,\n    IdToken: id_token,\n    RefreshToken: refresh_token,\n    TokenType: token_type,\n    ExpiresIn: expires_in\n  });\n  return completeFlow({\n    redirectUri,\n    state: validatedState,\n    preferPrivateSession\n  });\n}\nasync function handleImplicitFlow({\n  currentUrl,\n  redirectUri,\n  preferPrivateSession\n}) {\n  // hash is `null` if `#` doesn't exist on URL\n  const url = new AmplifyUrl(currentUrl);\n  const {\n    id_token,\n    access_token,\n    state,\n    token_type,\n    expires_in,\n    error_description,\n    error\n  } = (url.hash ?? '#').substring(1) // Remove # from returned code\n  .split('&').map(pairings => pairings.split('=')).reduce((accum, [k, v]) => ({\n    ...accum,\n    [k]: v\n  }), {\n    id_token: undefined,\n    access_token: undefined,\n    state: undefined,\n    token_type: undefined,\n    expires_in: undefined,\n    error_description: undefined,\n    error: undefined\n  });\n  if (error) {\n    invokeAndClearPromise();\n    await handleFailure(error_description ?? error);\n  }\n  if (!access_token) {\n    await store.clearOAuthData();\n    invokeAndClearPromise();\n    return;\n  }\n  let validatedState;\n  try {\n    validatedState = await validateState(state);\n  } catch (error) {\n    invokeAndClearPromise();\n    // validateState method will always throw an AuthError when the state is not valid. The if statement is making TS happy.\n    if (error instanceof AuthError) {\n      await handleFailure(error.message);\n    }\n    return;\n  }\n  const username = (access_token && decodeJWT(access_token).payload.username) ?? 'username';\n  await cacheCognitoTokens({\n    username,\n    AccessToken: access_token,\n    IdToken: id_token,\n    TokenType: token_type,\n    ExpiresIn: expires_in\n  });\n  return completeFlow({\n    redirectUri,\n    state: validatedState,\n    preferPrivateSession\n  });\n}\nasync function completeFlow({\n  redirectUri,\n  state,\n  preferPrivateSession\n}) {\n  await store.clearOAuthData();\n  await store.storeOAuthSignIn(true, preferPrivateSession);\n  if (isCustomState(state)) {\n    Hub.dispatch('auth', {\n      event: 'customOAuthState',\n      data: urlSafeDecode(getCustomState(state))\n    }, 'Auth', AMPLIFY_SYMBOL);\n  }\n  Hub.dispatch('auth', {\n    event: 'signInWithRedirect'\n  }, 'Auth', AMPLIFY_SYMBOL);\n  Hub.dispatch('auth', {\n    event: 'signedIn',\n    data: await getCurrentUser()\n  }, 'Auth', AMPLIFY_SYMBOL);\n  clearHistory(redirectUri);\n  invokeAndClearPromise();\n}\nasync function handleAuthResponse({\n  currentUrl,\n  userAgentValue,\n  clientId,\n  redirectUri,\n  responseType,\n  domain,\n  preferPrivateSession\n}) {\n  try {\n    const urlParams = new AmplifyUrl(currentUrl);\n    const error = urlParams.searchParams.get('error');\n    const errorMessage = urlParams.searchParams.get('error_description');\n    if (error) {\n      await handleFailure(errorMessage);\n    }\n    if (responseType === 'code') {\n      return await handleCodeFlow({\n        currentUrl,\n        userAgentValue,\n        clientId,\n        redirectUri,\n        domain,\n        preferPrivateSession\n      });\n    } else {\n      return await handleImplicitFlow({\n        currentUrl,\n        redirectUri,\n        preferPrivateSession\n      });\n    }\n  } catch (e) {\n    throw e;\n  }\n}\nfunction getStateFromURL(urlParams) {\n  return urlParams.searchParams.get('state');\n}\nasync function validateState(state) {\n  const savedState = await store.loadOAuthState();\n  // This is because savedState only exists if the flow was initiated by Amplify\n  const validatedState = state === savedState ? savedState : undefined;\n  if (!validatedState) {\n    throw new AuthError({\n      name: AuthErrorTypes.OAuthSignInError,\n      message: 'An error occurred while validating the state',\n      recoverySuggestion: 'Try to initiate an OAuth flow from Amplify'\n    });\n  }\n  return validatedState;\n}\nasync function handleFailure(errorMessage) {\n  const error = new AuthError({\n    message: errorMessage ?? 'An error has occurred during the oauth proccess',\n    name: AuthErrorCodes.OAuthSignInError,\n    recoverySuggestion: authErrorMessages.oauthSignInError.log\n  });\n  await store.clearOAuthInflightData();\n  Hub.dispatch('auth', {\n    event: 'signInWithRedirect_failure',\n    data: {\n      error\n    }\n  }, 'Auth', AMPLIFY_SYMBOL);\n  throw new AuthError({\n    message: errorMessage ?? '',\n    name: AuthErrorCodes.OAuthSignInError,\n    recoverySuggestion: authErrorMessages.oauthSignInError.log\n  });\n}\nasync function parseRedirectURL() {\n  const authConfig = Amplify.getConfig().Auth?.Cognito;\n  try {\n    assertTokenProviderConfig(authConfig);\n    store.setAuthConfig(authConfig);\n  } catch (_err) {\n    // Token provider not configure nothing to do\n    return;\n  }\n  // No OAuth inflight doesnt need to parse the url\n  if (!(await store.loadOAuthInFlight())) {\n    return;\n  }\n  try {\n    assertOAuthConfig(authConfig);\n  } catch (err) {\n    // TODO(v6): this should warn you have signInWithRedirect but is not configured\n    return;\n  }\n  try {\n    const currentUrl = window.location.href;\n    const {\n      loginWith,\n      userPoolClientId\n    } = authConfig;\n    const {\n      domain,\n      redirectSignIn,\n      responseType\n    } = loginWith.oauth;\n    await handleAuthResponse({\n      currentUrl,\n      clientId: userPoolClientId,\n      domain,\n      redirectUri: redirectSignIn[0],\n      responseType,\n      userAgentValue: getAuthUserAgentValue(AuthAction.SignInWithRedirect)\n    });\n  } catch (err) {\n    // is ok if there is not OAuthConfig\n  }\n}\nfunction urlListener() {\n  // Listen configure to parse url\n  parseRedirectURL();\n  Hub.listen('core', capsule => {\n    if (capsule.payload.event === 'configure') {\n      parseRedirectURL();\n    }\n  });\n}\nisBrowser() && urlListener();\n// This has a reference for listeners that requires to be notified, TokenOrchestrator use this for load tokens\nlet inflightPromiseResolvers = [];\nconst invokeAndClearPromise = () => {\n  for (const promiseResolver of inflightPromiseResolvers) {\n    promiseResolver();\n  }\n  inflightPromiseResolvers = [];\n};\nisBrowser() && cognitoUserPoolsTokenProvider.setWaitForInflightOAuth(() => new Promise(async (res, _rej) => {\n  if (!(await store.loadOAuthInFlight())) {\n    res();\n  } else {\n    inflightPromiseResolvers.push(res);\n  }\n  return;\n}));\nfunction clearHistory(redirectUri) {\n  if (typeof window !== 'undefined' && typeof window.history !== 'undefined') {\n    window.history.replaceState({}, '', redirectUri);\n  }\n}\nfunction isCustomState(state) {\n  return /-/.test(state);\n}\nfunction getCustomState(state) {\n  return state.split('-').splice(1).join('-');\n}\nexport { oauthSignIn, parseRedirectURL, signInWithRedirect, store };","map":{"version":3,"names":["signInWithRedirect","input","authConfig","Amplify","getConfig","Auth","Cognito","assertTokenProviderConfig","assertOAuthConfig","store","setAuthConfig","assertUserNotAuthenticated","provider","cognitoHostedUIIdentityProviderMap","custom","oauthSignIn","oauthConfig","loginWith","oauth","clientId","userPoolClientId","customState","preferPrivateSession","options","DefaultOAuthStore","defaultStorage","domain","redirectSignIn","responseType","scopes","randomState","generateState","state","urlSafeEncode","value","method","toCodeChallenge","generateCodeVerifier","redirectUri","getRedirectUrl","storeOAuthInFlight","storeOAuthState","storePKCE","queryString","Object","entries","redirect_uri","response_type","client_id","identity_provider","scope","join","code_challenge","code_challenge_method","map","k","v","encodeURIComponent","oAuthUrl","type","error","url","openAuthSession","handleAuthResponse","currentUrl","userAgentValue","getAuthUserAgentValue","AuthAction","SignInWithRedirect","handleFailure","String","handleCodeFlow","AmplifyUrl","validatedState","validateState","getStateFromURL","err","invokeAndClearPromise","AuthError","message","code","searchParams","get","clearOAuthData","oAuthTokenEndpoint","codeVerifier","loadPKCE","oAuthTokenBody","grant_type","code_verifier","body","access_token","refresh_token","id_token","error_message","token_type","expires_in","fetch","headers","USER_AGENT_HEADER","json","clearOAuthInflightData","username","decodeJWT","payload","cacheCognitoTokens","AccessToken","IdToken","RefreshToken","TokenType","ExpiresIn","completeFlow","handleImplicitFlow","error_description","hash","substring","split","pairings","reduce","accum","undefined","storeOAuthSignIn","isCustomState","Hub","dispatch","event","data","urlSafeDecode","getCustomState","AMPLIFY_SYMBOL","getCurrentUser","clearHistory","urlParams","errorMessage","e","savedState","loadOAuthState","name","AuthErrorTypes","OAuthSignInError","recoverySuggestion","AuthErrorCodes","authErrorMessages","oauthSignInError","log","parseRedirectURL","_err","loadOAuthInFlight","window","location","href","urlListener","listen","capsule","isBrowser","inflightPromiseResolvers","promiseResolver","cognitoUserPoolsTokenProvider","setWaitForInflightOAuth","Promise","res","_rej","push","history","replaceState","test","splice"],"sources":["E:\\CSC-PROJECT\\amplify-react-app\\node_modules\\@aws-amplify\\auth\\src\\providers\\cognito\\apis\\signInWithRedirect.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Amplify, Hub, defaultStorage } from '@aws-amplify/core';\nimport { AuthAction, AMPLIFY_SYMBOL, assertOAuthConfig, assertTokenProviderConfig, isBrowser, urlSafeEncode, USER_AGENT_HEADER, urlSafeDecode, decodeJWT, AmplifyUrl, } from '@aws-amplify/core/internals/utils';\nimport { cacheCognitoTokens } from '../tokenProvider/cacheTokens';\nimport { cognitoUserPoolsTokenProvider } from '../tokenProvider';\nimport { cognitoHostedUIIdentityProviderMap } from '../types/models';\nimport { DefaultOAuthStore } from '../utils/signInWithRedirectStore';\nimport { AuthError } from '../../../errors/AuthError';\nimport { AuthErrorTypes } from '../../../types/Auth';\nimport { AuthErrorCodes } from '../../../common/AuthErrorStrings';\nimport { authErrorMessages } from '../../../Errors';\nimport { getAuthUserAgentValue, openAuthSession } from '../../../utils';\nimport { assertUserNotAuthenticated } from '../utils/signInHelpers';\nimport { generateCodeVerifier, generateState } from '../utils/oauth';\nimport { getCurrentUser } from './getCurrentUser';\nimport { getRedirectUrl } from '../utils/oauth/getRedirectUrl';\n/**\n * Signs in a user with OAuth. Redirects the application to an Identity Provider.\n *\n * @param input - The SignInWithRedirectInput object, if empty it will redirect to Cognito HostedUI\n *\n * @throws AuthTokenConfigException - Thrown when the userpool config is invalid.\n * @throws OAuthNotConfigureException - Thrown when the oauth config is invalid.\n */\nexport async function signInWithRedirect(input) {\n    const authConfig = Amplify.getConfig().Auth?.Cognito;\n    assertTokenProviderConfig(authConfig);\n    assertOAuthConfig(authConfig);\n    store.setAuthConfig(authConfig);\n    await assertUserNotAuthenticated();\n    let provider = 'COGNITO'; // Default\n    if (typeof input?.provider === 'string') {\n        provider = cognitoHostedUIIdentityProviderMap[input.provider];\n    }\n    else if (input?.provider?.custom) {\n        provider = input.provider.custom;\n    }\n    return oauthSignIn({\n        oauthConfig: authConfig.loginWith.oauth,\n        clientId: authConfig.userPoolClientId,\n        provider,\n        customState: input?.customState,\n        preferPrivateSession: input?.options?.preferPrivateSession,\n    });\n}\nexport const store = new DefaultOAuthStore(defaultStorage);\nexport async function oauthSignIn({ oauthConfig, provider, clientId, customState, preferPrivateSession, }) {\n    const { domain, redirectSignIn, responseType, scopes } = oauthConfig;\n    const randomState = generateState();\n    /* encodeURIComponent is not URL safe, use urlSafeEncode instead. Cognito\n    single-encodes/decodes url on first sign in and double-encodes/decodes url\n    when user already signed in. Using encodeURIComponent, Base32, Base64 add\n    characters % or = which on further encoding becomes unsafe. '=' create issue\n    for parsing query params.\n    Refer: https://github.com/aws-amplify/amplify-js/issues/5218 */\n    const state = customState\n        ? `${randomState}-${urlSafeEncode(customState)}`\n        : randomState;\n    const { value, method, toCodeChallenge } = generateCodeVerifier(128);\n    const redirectUri = getRedirectUrl(oauthConfig.redirectSignIn);\n    store.storeOAuthInFlight(true);\n    store.storeOAuthState(state);\n    store.storePKCE(value);\n    const queryString = Object.entries({\n        redirect_uri: redirectUri,\n        response_type: responseType,\n        client_id: clientId,\n        identity_provider: provider,\n        scope: scopes.join(' '),\n        state,\n        ...(responseType === 'code' && {\n            code_challenge: toCodeChallenge(),\n            code_challenge_method: method,\n        }),\n    })\n        .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)\n        .join('&');\n    // TODO(v6): use URL object instead\n    const oAuthUrl = `https://${domain}/oauth2/authorize?${queryString}`;\n    const { type, error, url } = (await openAuthSession(oAuthUrl, redirectSignIn, preferPrivateSession)) ??\n        {};\n    // This code will run in RN applications only as calling signInWithRedirect will\n    // resolve the promise.\n    if (type === 'success' && url) {\n        // ensure the code exchange completion resolves the signInWithRedirect\n        // returned promise in react-native\n        await handleAuthResponse({\n            currentUrl: url,\n            clientId,\n            domain,\n            redirectUri: redirectSignIn[0],\n            responseType,\n            userAgentValue: getAuthUserAgentValue(AuthAction.SignInWithRedirect),\n            preferPrivateSession,\n        });\n    }\n    // This code will run in RN applications only as calling signInWithRedirect will\n    // resolve the promise.\n    if (type === 'error') {\n        await handleFailure(String(error));\n    }\n}\nasync function handleCodeFlow({ currentUrl, userAgentValue, clientId, redirectUri, domain, preferPrivateSession, }) {\n    /* Convert URL into an object with parameters as keys\n{ redirect_uri: 'http://localhost:3000/', response_type: 'code', ...} */\n    const url = new AmplifyUrl(currentUrl);\n    let validatedState;\n    try {\n        validatedState = await validateState(getStateFromURL(url));\n    }\n    catch (err) {\n        invokeAndClearPromise();\n        // validateState method will always throw an AuthError when the state is not valid. The if statement is making TS happy.\n        if (err instanceof AuthError) {\n            await handleFailure(err.message);\n        }\n        return;\n    }\n    const code = url.searchParams.get('code');\n    if (!code) {\n        await store.clearOAuthData();\n        invokeAndClearPromise();\n        return;\n    }\n    const oAuthTokenEndpoint = 'https://' + domain + '/oauth2/token';\n    // TODO(v6): check hub events\n    // dispatchAuthEvent(\n    // \t'codeFlow',\n    // \t{},\n    // \t`Retrieving tokens from ${oAuthTokenEndpoint}`\n    // );\n    const codeVerifier = await store.loadPKCE();\n    const oAuthTokenBody = {\n        grant_type: 'authorization_code',\n        code,\n        client_id: clientId,\n        redirect_uri: redirectUri,\n        ...(codeVerifier ? { code_verifier: codeVerifier } : {}),\n    };\n    const body = Object.entries(oAuthTokenBody)\n        .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)\n        .join('&');\n    const { access_token, refresh_token, id_token, error, error_message, token_type, expires_in, } = await (await fetch(oAuthTokenEndpoint, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            [USER_AGENT_HEADER]: userAgentValue,\n        },\n        body,\n    })).json();\n    if (error) {\n        invokeAndClearPromise();\n        await handleFailure(error_message ?? error);\n    }\n    await store.clearOAuthInflightData();\n    const username = (access_token && decodeJWT(access_token).payload.username) ?? 'username';\n    await cacheCognitoTokens({\n        username,\n        AccessToken: access_token,\n        IdToken: id_token,\n        RefreshToken: refresh_token,\n        TokenType: token_type,\n        ExpiresIn: expires_in,\n    });\n    return completeFlow({\n        redirectUri,\n        state: validatedState,\n        preferPrivateSession,\n    });\n}\nasync function handleImplicitFlow({ currentUrl, redirectUri, preferPrivateSession, }) {\n    // hash is `null` if `#` doesn't exist on URL\n    const url = new AmplifyUrl(currentUrl);\n    const { id_token, access_token, state, token_type, expires_in, error_description, error, } = (url.hash ?? '#')\n        .substring(1) // Remove # from returned code\n        .split('&')\n        .map(pairings => pairings.split('='))\n        .reduce((accum, [k, v]) => ({ ...accum, [k]: v }), {\n        id_token: undefined,\n        access_token: undefined,\n        state: undefined,\n        token_type: undefined,\n        expires_in: undefined,\n        error_description: undefined,\n        error: undefined,\n    });\n    if (error) {\n        invokeAndClearPromise();\n        await handleFailure(error_description ?? error);\n    }\n    if (!access_token) {\n        await store.clearOAuthData();\n        invokeAndClearPromise();\n        return;\n    }\n    let validatedState;\n    try {\n        validatedState = await validateState(state);\n    }\n    catch (error) {\n        invokeAndClearPromise();\n        // validateState method will always throw an AuthError when the state is not valid. The if statement is making TS happy.\n        if (error instanceof AuthError) {\n            await handleFailure(error.message);\n        }\n        return;\n    }\n    const username = (access_token && decodeJWT(access_token).payload.username) ?? 'username';\n    await cacheCognitoTokens({\n        username,\n        AccessToken: access_token,\n        IdToken: id_token,\n        TokenType: token_type,\n        ExpiresIn: expires_in,\n    });\n    return completeFlow({\n        redirectUri,\n        state: validatedState,\n        preferPrivateSession,\n    });\n}\nasync function completeFlow({ redirectUri, state, preferPrivateSession, }) {\n    await store.clearOAuthData();\n    await store.storeOAuthSignIn(true, preferPrivateSession);\n    if (isCustomState(state)) {\n        Hub.dispatch('auth', {\n            event: 'customOAuthState',\n            data: urlSafeDecode(getCustomState(state)),\n        }, 'Auth', AMPLIFY_SYMBOL);\n    }\n    Hub.dispatch('auth', { event: 'signInWithRedirect' }, 'Auth', AMPLIFY_SYMBOL);\n    Hub.dispatch('auth', { event: 'signedIn', data: await getCurrentUser() }, 'Auth', AMPLIFY_SYMBOL);\n    clearHistory(redirectUri);\n    invokeAndClearPromise();\n}\nasync function handleAuthResponse({ currentUrl, userAgentValue, clientId, redirectUri, responseType, domain, preferPrivateSession, }) {\n    try {\n        const urlParams = new AmplifyUrl(currentUrl);\n        const error = urlParams.searchParams.get('error');\n        const errorMessage = urlParams.searchParams.get('error_description');\n        if (error) {\n            await handleFailure(errorMessage);\n        }\n        if (responseType === 'code') {\n            return await handleCodeFlow({\n                currentUrl,\n                userAgentValue,\n                clientId,\n                redirectUri,\n                domain,\n                preferPrivateSession,\n            });\n        }\n        else {\n            return await handleImplicitFlow({\n                currentUrl,\n                redirectUri,\n                preferPrivateSession,\n            });\n        }\n    }\n    catch (e) {\n        throw e;\n    }\n}\nfunction getStateFromURL(urlParams) {\n    return urlParams.searchParams.get('state');\n}\nasync function validateState(state) {\n    const savedState = await store.loadOAuthState();\n    // This is because savedState only exists if the flow was initiated by Amplify\n    const validatedState = state === savedState ? savedState : undefined;\n    if (!validatedState) {\n        throw new AuthError({\n            name: AuthErrorTypes.OAuthSignInError,\n            message: 'An error occurred while validating the state',\n            recoverySuggestion: 'Try to initiate an OAuth flow from Amplify',\n        });\n    }\n    return validatedState;\n}\nasync function handleFailure(errorMessage) {\n    const error = new AuthError({\n        message: errorMessage ?? 'An error has occurred during the oauth proccess',\n        name: AuthErrorCodes.OAuthSignInError,\n        recoverySuggestion: authErrorMessages.oauthSignInError.log,\n    });\n    await store.clearOAuthInflightData();\n    Hub.dispatch('auth', { event: 'signInWithRedirect_failure', data: { error } }, 'Auth', AMPLIFY_SYMBOL);\n    throw new AuthError({\n        message: errorMessage ?? '',\n        name: AuthErrorCodes.OAuthSignInError,\n        recoverySuggestion: authErrorMessages.oauthSignInError.log,\n    });\n}\nexport async function parseRedirectURL() {\n    const authConfig = Amplify.getConfig().Auth?.Cognito;\n    try {\n        assertTokenProviderConfig(authConfig);\n        store.setAuthConfig(authConfig);\n    }\n    catch (_err) {\n        // Token provider not configure nothing to do\n        return;\n    }\n    // No OAuth inflight doesnt need to parse the url\n    if (!(await store.loadOAuthInFlight())) {\n        return;\n    }\n    try {\n        assertOAuthConfig(authConfig);\n    }\n    catch (err) {\n        // TODO(v6): this should warn you have signInWithRedirect but is not configured\n        return;\n    }\n    try {\n        const currentUrl = window.location.href;\n        const { loginWith, userPoolClientId } = authConfig;\n        const { domain, redirectSignIn, responseType } = loginWith.oauth;\n        await handleAuthResponse({\n            currentUrl,\n            clientId: userPoolClientId,\n            domain,\n            redirectUri: redirectSignIn[0],\n            responseType,\n            userAgentValue: getAuthUserAgentValue(AuthAction.SignInWithRedirect),\n        });\n    }\n    catch (err) {\n        // is ok if there is not OAuthConfig\n    }\n}\nfunction urlListener() {\n    // Listen configure to parse url\n    parseRedirectURL();\n    Hub.listen('core', capsule => {\n        if (capsule.payload.event === 'configure') {\n            parseRedirectURL();\n        }\n    });\n}\nisBrowser() && urlListener();\n// This has a reference for listeners that requires to be notified, TokenOrchestrator use this for load tokens\nlet inflightPromiseResolvers = [];\nconst invokeAndClearPromise = () => {\n    for (const promiseResolver of inflightPromiseResolvers) {\n        promiseResolver();\n    }\n    inflightPromiseResolvers = [];\n};\nisBrowser() &&\n    cognitoUserPoolsTokenProvider.setWaitForInflightOAuth(() => new Promise(async (res, _rej) => {\n        if (!(await store.loadOAuthInFlight())) {\n            res();\n        }\n        else {\n            inflightPromiseResolvers.push(res);\n        }\n        return;\n    }));\nfunction clearHistory(redirectUri) {\n    if (typeof window !== 'undefined' && typeof window.history !== 'undefined') {\n        window.history.replaceState({}, '', redirectUri);\n    }\n}\nfunction isCustomState(state) {\n    return /-/.test(state);\n}\nfunction getCustomState(state) {\n    return state.split('-').splice(1).join('-');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}