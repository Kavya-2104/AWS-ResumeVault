{"ast":null,"code":"import * as React from 'react';\nimport { isFunction } from '@aws-amplify/ui';\nconst getCorrectSteppingValue = ({\n  max,\n  min,\n  step,\n  value\n}) => {\n  // Round it to the closest step value\n  // It will be based off min to be consistent with native input[type=\"number\"]\n  // This allows keyboard accessible\n  const remainder = (value - min) % step;\n  value = value - remainder + Math.round(remainder / step) * step;\n  // Make sure new value is not outside the bound\n  value = Math.max(min, value);\n  if (value > max) {\n    value = max - (max - min) % step;\n  }\n  return value;\n};\nconst useStepper = ({\n  defaultValue = 0,\n  value: controlledValue,\n  step = 1,\n  max = Number.MAX_SAFE_INTEGER,\n  min = Number.MIN_SAFE_INTEGER,\n  isDisabled,\n  isReadOnly,\n  onChange,\n  onDecrease,\n  onIncrease,\n  onStepChange\n}) => {\n  const isControlled = controlledValue !== undefined;\n  // Make sure max value is greater than or equal to min value\n  max = Math.max(min, max);\n  // Maintain an internal state for uncontrolled components\n  // This allows to take over the input value and correct any invalid versus purely relying on the native uncontrolled input\n  const [uncontrolledValue, setUncontrolledValue] = React.useState(() =>\n  // This is required for users could provide any defaultValue\n  getCorrectSteppingValue({\n    min,\n    max,\n    step,\n    value: defaultValue\n  }));\n  // Same for controlled components on the first render because users could provide invalid initial value.\n  // It seems redundant afterwards but necessary for the first render\n  const value = isControlled ? getCorrectSteppingValue({\n    min,\n    max,\n    step,\n    value: controlledValue\n  }) : uncontrolledValue;\n  const shouldDisableIncreaseButton = isDisabled ?? isReadOnly ?? value + step > max;\n  const shouldDisableDecreaseButton = isDisabled ?? isReadOnly ?? value - step < min;\n  // This is the exact value to be rendered on screen\n  // It could be a string, like '-' or empty string when users clear the input\n  const [inputValue, setInputValue] = React.useState(value);\n  const handleOnChange = React.useCallback(event => {\n    setInputValue(event.target.value);\n    if (isFunction(onChange)) {\n      onChange(event);\n    }\n  }, [onChange]);\n  const handleOnBlur = React.useCallback(event => {\n    const parsedValue = parseFloat(event.target.value);\n    // Though input[type='number'] has built-in validation to reject non-numerical entries\n    // The entered value could still be empty string or minus '-'\n    // in these cases, no need to do the following validation\n    if (isNaN(parsedValue)) {\n      return;\n    }\n    const newValue = getCorrectSteppingValue({\n      min,\n      max,\n      step,\n      value: parsedValue\n    });\n    if (!isControlled) {\n      setUncontrolledValue(newValue);\n    }\n    if (isFunction(onStepChange)) {\n      onStepChange(newValue);\n    }\n    setInputValue(newValue);\n  }, [min, max, step, isControlled, onStepChange]);\n  const handleIncrease = React.useCallback(() => {\n    // No need to check if the value will be outside the bounds\n    // The button will be disabled if so\n    if (!isControlled) {\n      setUncontrolledValue(value + step);\n    }\n    if (isFunction(onStepChange)) {\n      onStepChange(value + step);\n    }\n    if (isFunction(onIncrease)) {\n      onIncrease();\n    }\n    setInputValue(value + step);\n  }, [step, value, isControlled, onIncrease, onStepChange]);\n  const handleDecrease = React.useCallback(() => {\n    // No need to check if the value will be outside the bounds\n    // The button will be disabled if so\n    if (!isControlled) {\n      setUncontrolledValue(value - step);\n    }\n    if (isFunction(onStepChange)) {\n      onStepChange(value - step);\n    }\n    if (isFunction(onDecrease)) {\n      onDecrease();\n    }\n    setInputValue(value - step);\n  }, [step, value, isControlled, onDecrease, onStepChange]);\n  // This aims to disable unwanted behaviors on React input[type='number']\n  // When the input gets focused, rotating a wheel will change its value\n  // But the parent container(mostly the entire window) will be scrolling to elsewhere\n  const handleOnWheel = React.useCallback(event => {\n    event.currentTarget.blur();\n  }, []);\n  return {\n    step,\n    value,\n    inputValue,\n    handleDecrease,\n    handleIncrease,\n    handleOnBlur,\n    handleOnChange,\n    handleOnWheel,\n    setInputValue,\n    shouldDisableDecreaseButton,\n    shouldDisableIncreaseButton\n  };\n};\nexport { useStepper };","map":{"version":3,"names":["React","isFunction","getCorrectSteppingValue","max","min","step","value","remainder","Math","round","useStepper","defaultValue","controlledValue","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","isDisabled","isReadOnly","onChange","onDecrease","onIncrease","onStepChange","isControlled","undefined","uncontrolledValue","setUncontrolledValue","useState","shouldDisableIncreaseButton","shouldDisableDecreaseButton","inputValue","setInputValue","handleOnChange","useCallback","event","target","handleOnBlur","parsedValue","parseFloat","isNaN","newValue","handleIncrease","handleDecrease","handleOnWheel","currentTarget","blur"],"sources":["E:/CSC-PROJECT/amplify-react-app/node_modules/@aws-amplify/ui-react/dist/esm/primitives/StepperField/useStepper.mjs"],"sourcesContent":["import * as React from 'react';\nimport { isFunction } from '@aws-amplify/ui';\n\nconst getCorrectSteppingValue = ({ max, min, step, value, }) => {\n    // Round it to the closest step value\n    // It will be based off min to be consistent with native input[type=\"number\"]\n    // This allows keyboard accessible\n    const remainder = (value - min) % step;\n    value = value - remainder + Math.round(remainder / step) * step;\n    // Make sure new value is not outside the bound\n    value = Math.max(min, value);\n    if (value > max) {\n        value = max - ((max - min) % step);\n    }\n    return value;\n};\nconst useStepper = ({ defaultValue = 0, value: controlledValue, step = 1, max = Number.MAX_SAFE_INTEGER, min = Number.MIN_SAFE_INTEGER, isDisabled, isReadOnly, onChange, onDecrease, onIncrease, onStepChange, }) => {\n    const isControlled = controlledValue !== undefined;\n    // Make sure max value is greater than or equal to min value\n    max = Math.max(min, max);\n    // Maintain an internal state for uncontrolled components\n    // This allows to take over the input value and correct any invalid versus purely relying on the native uncontrolled input\n    const [uncontrolledValue, setUncontrolledValue] = React.useState(() => \n    // This is required for users could provide any defaultValue\n    getCorrectSteppingValue({ min, max, step, value: defaultValue }));\n    // Same for controlled components on the first render because users could provide invalid initial value.\n    // It seems redundant afterwards but necessary for the first render\n    const value = isControlled\n        ? getCorrectSteppingValue({ min, max, step, value: controlledValue })\n        : uncontrolledValue;\n    const shouldDisableIncreaseButton = isDisabled ?? isReadOnly ?? value + step > max;\n    const shouldDisableDecreaseButton = isDisabled ?? isReadOnly ?? value - step < min;\n    // This is the exact value to be rendered on screen\n    // It could be a string, like '-' or empty string when users clear the input\n    const [inputValue, setInputValue] = React.useState(value);\n    const handleOnChange = React.useCallback((event) => {\n        setInputValue(event.target.value);\n        if (isFunction(onChange)) {\n            onChange(event);\n        }\n    }, [onChange]);\n    const handleOnBlur = React.useCallback((event) => {\n        const parsedValue = parseFloat(event.target.value);\n        // Though input[type='number'] has built-in validation to reject non-numerical entries\n        // The entered value could still be empty string or minus '-'\n        // in these cases, no need to do the following validation\n        if (isNaN(parsedValue)) {\n            return;\n        }\n        const newValue = getCorrectSteppingValue({\n            min,\n            max,\n            step,\n            value: parsedValue,\n        });\n        if (!isControlled) {\n            setUncontrolledValue(newValue);\n        }\n        if (isFunction(onStepChange)) {\n            onStepChange(newValue);\n        }\n        setInputValue(newValue);\n    }, [min, max, step, isControlled, onStepChange]);\n    const handleIncrease = React.useCallback(() => {\n        // No need to check if the value will be outside the bounds\n        // The button will be disabled if so\n        if (!isControlled) {\n            setUncontrolledValue(value + step);\n        }\n        if (isFunction(onStepChange)) {\n            onStepChange(value + step);\n        }\n        if (isFunction(onIncrease)) {\n            onIncrease();\n        }\n        setInputValue(value + step);\n    }, [step, value, isControlled, onIncrease, onStepChange]);\n    const handleDecrease = React.useCallback(() => {\n        // No need to check if the value will be outside the bounds\n        // The button will be disabled if so\n        if (!isControlled) {\n            setUncontrolledValue(value - step);\n        }\n        if (isFunction(onStepChange)) {\n            onStepChange(value - step);\n        }\n        if (isFunction(onDecrease)) {\n            onDecrease();\n        }\n        setInputValue(value - step);\n    }, [step, value, isControlled, onDecrease, onStepChange]);\n    // This aims to disable unwanted behaviors on React input[type='number']\n    // When the input gets focused, rotating a wheel will change its value\n    // But the parent container(mostly the entire window) will be scrolling to elsewhere\n    const handleOnWheel = React.useCallback((event) => {\n        event.currentTarget.blur();\n    }, []);\n    return {\n        step,\n        value,\n        inputValue,\n        handleDecrease,\n        handleIncrease,\n        handleOnBlur,\n        handleOnChange,\n        handleOnWheel,\n        setInputValue,\n        shouldDisableDecreaseButton,\n        shouldDisableIncreaseButton,\n    };\n};\n\nexport { useStepper };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}