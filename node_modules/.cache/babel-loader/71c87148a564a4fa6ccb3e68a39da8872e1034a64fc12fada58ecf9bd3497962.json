{"ast":null,"code":"import deepExtend from 'style-dictionary/lib/utils/deepExtend.js';\nimport flattenProperties from 'style-dictionary/lib/utils/flattenProperties.js';\nimport { defaultTheme } from './defaultTheme.mjs';\nimport { setupTokens, cssNameTransform, cssValue } from './utils.mjs';\nimport '@aws-amplify/core/internals/utils';\nimport '../utils/setUserAgent/constants.mjs';\nimport { isString } from '../utils/utils.mjs';\n\n// Internal Style Dictionary methods\n/**\n * This will take a design token and add some data to it for it\n * to be used in JS/CSS. It will create its CSS var name and update\n * the value to use a CSS var if it is a reference. It will also\n * add a `.toString()` method to make it easier to use in JS.\n *\n * We should see if there is a way to share this logic with style dictionary...\n */\nconst setupToken = ({\n  token,\n  path\n}) => {\n  const name = `--${cssNameTransform({\n    path\n  })}`;\n  const {\n    value: original\n  } = token;\n  const value = cssValue(token);\n  return {\n    name,\n    original,\n    path,\n    value,\n    toString: () => `var(${name})`\n  };\n};\n/**\n * Takes a set of keys and a color name and returns an object of design tokens,\n * used for applying a primary color at the theme level to our tokens.\n *\n * createColorPalette({keys: ['10','20',...], value: 'red'})\n * returns {\n *   10: { value: '{colors.red.10.value}' },\n *   20: { value: '{colors.red.20.value}' },\n *   ...\n * }\n */\nfunction createColorPalette({\n  keys,\n  value\n}) {\n  return keys.reduce((acc, key) => {\n    return {\n      ...acc,\n      [key]: {\n        value: `{colors.${value}.${key}.value}`\n      }\n    };\n  }, {});\n}\n/**\n * This will be used like `const myTheme = createTheme({})`\n * `myTheme` can then be passed to a Provider or the generated CSS\n * can be passed to a stylesheet at build-time or run-time.\n * const myTheme = createTheme({})\n * const myOtherTheme = createTheme({}, myTheme);\n */\nfunction createTheme(theme, DefaultTheme = defaultTheme) {\n  // merge theme and DefaultTheme to get a complete theme\n  // deepExtend is an internal Style Dictionary method\n  // that performs a deep merge on n objects. We could change\n  // this to another 3p deep merge solution too.\n  const mergedTheme = deepExtend([{}, DefaultTheme, theme]);\n  const {\n    primaryColor,\n    secondaryColor\n  } = mergedTheme;\n  // apply primaryColor and secondaryColor if present\n  if (isString(primaryColor)) {\n    mergedTheme.tokens.colors.primary = createColorPalette({\n      keys: Object.keys(mergedTheme.tokens.colors[primaryColor]),\n      value: primaryColor\n    });\n  }\n  if (isString(secondaryColor)) {\n    mergedTheme.tokens.colors.secondary = createColorPalette({\n      keys: Object.keys(mergedTheme.tokens.colors[secondaryColor]),\n      value: secondaryColor\n    });\n  }\n  // Setting up the tokens. This is similar to what Style Dictionary\n  // does. At the end of this, each token should have:\n  // - CSS variable name of itself\n  // - its value (reference to another CSS variable or raw value)\n  const tokens = setupTokens({\n    tokens: mergedTheme.tokens,\n    setupToken\n  }); // Setting the type here because setupTokens is recursive\n  const {\n    breakpoints,\n    name\n  } = mergedTheme;\n  // flattenProperties is another internal Style Dictionary function\n  // that creates an array of all tokens.\n  let cssText = `[data-amplify-theme=\"${name}\"] {\\n` + flattenProperties(tokens).map(token => `${token.name}: ${token.value};`).join('\\n') + `\\n}\\n`;\n  let overrides = [];\n  /**\n   * For each override, we setup the tokens and then generate the CSS.\n   * This allows us to have one single CSS string for all possible overrides\n   * and avoid re-renders in React, but also support other frameworks as well.\n   */\n  if (mergedTheme.overrides) {\n    overrides = mergedTheme.overrides.map(override => {\n      const tokens = setupTokens({\n        tokens: override.tokens,\n        setupToken\n      });\n      const customProperties = flattenProperties(tokens).map(token => `${token.name}: ${token.value};`).join('\\n');\n      // Overrides can have a selector, media query, breakpoint, or color mode\n      // for creating the selector\n      if ('selector' in override) {\n        cssText += `\\n${override.selector} {\\n${customProperties}\\n}\\n`;\n      }\n      if ('mediaQuery' in override) {\n        cssText += `\\n@media (${override.mediaQuery}) {\n  [data-amplify-theme=\"${name}\"] {\n    ${customProperties}\n  }\n}\\n`;\n      }\n      if ('breakpoint' in override) {\n        const breakpoint = mergedTheme.breakpoints.values[override.breakpoint];\n        cssText += `\\n@media (min-width: ${breakpoint}px) {\n  [data-amplify-theme=\"${name}\"] {\n    ${customProperties}\n  }\n}\\n`;\n      }\n      if ('colorMode' in override) {\n        cssText += `\\n@media (prefers-color-scheme: ${override.colorMode}) {\n          [data-amplify-theme=\"${name}\"][data-amplify-color-mode=\"system\"] {\n            ${customProperties}\n            color-scheme: ${override.colorMode};\n          }\n        }\\n`;\n        cssText += `\\n[data-amplify-theme=\"${name}\"][data-amplify-color-mode=\"${override.colorMode}\"] {\n          ${customProperties}\n          color-scheme: ${override.colorMode};\n        }\\n`;\n      }\n      return {\n        ...override,\n        tokens\n      };\n    });\n  }\n  return {\n    tokens,\n    breakpoints,\n    name,\n    cssText,\n    // keep overrides separate from base theme\n    // this allows web platforms to use plain CSS scoped to a\n    // selector and only override the CSS vars needed. This\n    // means we could generate CSS at build-time in a postcss\n    // plugin, or do it at runtime and inject the CSS into a\n    // style tag.\n    // This also allows RN to dynamically switch themes in a\n    // provider.\n    overrides\n  };\n}\nexport { createTheme };","map":{"version":3,"names":["deepExtend","flattenProperties","defaultTheme","setupTokens","cssNameTransform","cssValue","isString","setupToken","token","path","name","value","original","toString","createColorPalette","keys","reduce","acc","key","createTheme","theme","DefaultTheme","mergedTheme","primaryColor","secondaryColor","tokens","colors","primary","Object","secondary","breakpoints","cssText","map","join","overrides","override","customProperties","selector","mediaQuery","breakpoint","values","colorMode"],"sources":["E:/CSC-PROJECT/amplify-react-app/node_modules/@aws-amplify/ui/dist/esm/theme/createTheme.mjs"],"sourcesContent":["import deepExtend from 'style-dictionary/lib/utils/deepExtend.js';\nimport flattenProperties from 'style-dictionary/lib/utils/flattenProperties.js';\nimport { defaultTheme } from './defaultTheme.mjs';\nimport { setupTokens, cssNameTransform, cssValue } from './utils.mjs';\nimport '@aws-amplify/core/internals/utils';\nimport '../utils/setUserAgent/constants.mjs';\nimport { isString } from '../utils/utils.mjs';\n\n// Internal Style Dictionary methods\n/**\n * This will take a design token and add some data to it for it\n * to be used in JS/CSS. It will create its CSS var name and update\n * the value to use a CSS var if it is a reference. It will also\n * add a `.toString()` method to make it easier to use in JS.\n *\n * We should see if there is a way to share this logic with style dictionary...\n */\nconst setupToken = ({ token, path }) => {\n    const name = `--${cssNameTransform({ path })}`;\n    const { value: original } = token;\n    const value = cssValue(token);\n    return { name, original, path, value, toString: () => `var(${name})` };\n};\n/**\n * Takes a set of keys and a color name and returns an object of design tokens,\n * used for applying a primary color at the theme level to our tokens.\n *\n * createColorPalette({keys: ['10','20',...], value: 'red'})\n * returns {\n *   10: { value: '{colors.red.10.value}' },\n *   20: { value: '{colors.red.20.value}' },\n *   ...\n * }\n */\nfunction createColorPalette({ keys, value }) {\n    return keys.reduce((acc, key) => {\n        return {\n            ...acc,\n            [key]: { value: `{colors.${value}.${key}.value}` },\n        };\n    }, {});\n}\n/**\n * This will be used like `const myTheme = createTheme({})`\n * `myTheme` can then be passed to a Provider or the generated CSS\n * can be passed to a stylesheet at build-time or run-time.\n * const myTheme = createTheme({})\n * const myOtherTheme = createTheme({}, myTheme);\n */\nfunction createTheme(theme, DefaultTheme = defaultTheme) {\n    // merge theme and DefaultTheme to get a complete theme\n    // deepExtend is an internal Style Dictionary method\n    // that performs a deep merge on n objects. We could change\n    // this to another 3p deep merge solution too.\n    const mergedTheme = deepExtend([{}, DefaultTheme, theme]);\n    const { primaryColor, secondaryColor } = mergedTheme;\n    // apply primaryColor and secondaryColor if present\n    if (isString(primaryColor)) {\n        mergedTheme.tokens.colors.primary = createColorPalette({\n            keys: Object.keys(mergedTheme.tokens.colors[primaryColor]),\n            value: primaryColor,\n        });\n    }\n    if (isString(secondaryColor)) {\n        mergedTheme.tokens.colors.secondary = createColorPalette({\n            keys: Object.keys(mergedTheme.tokens.colors[secondaryColor]),\n            value: secondaryColor,\n        });\n    }\n    // Setting up the tokens. This is similar to what Style Dictionary\n    // does. At the end of this, each token should have:\n    // - CSS variable name of itself\n    // - its value (reference to another CSS variable or raw value)\n    const tokens = setupTokens({\n        tokens: mergedTheme.tokens,\n        setupToken,\n    }); // Setting the type here because setupTokens is recursive\n    const { breakpoints, name } = mergedTheme;\n    // flattenProperties is another internal Style Dictionary function\n    // that creates an array of all tokens.\n    let cssText = `[data-amplify-theme=\"${name}\"] {\\n` +\n        flattenProperties(tokens)\n            .map((token) => `${token.name}: ${token.value};`)\n            .join('\\n') +\n        `\\n}\\n`;\n    let overrides = [];\n    /**\n     * For each override, we setup the tokens and then generate the CSS.\n     * This allows us to have one single CSS string for all possible overrides\n     * and avoid re-renders in React, but also support other frameworks as well.\n     */\n    if (mergedTheme.overrides) {\n        overrides = mergedTheme.overrides.map((override) => {\n            const tokens = setupTokens({\n                tokens: override.tokens,\n                setupToken,\n            });\n            const customProperties = flattenProperties(tokens)\n                .map((token) => `${token.name}: ${token.value};`)\n                .join('\\n');\n            // Overrides can have a selector, media query, breakpoint, or color mode\n            // for creating the selector\n            if ('selector' in override) {\n                cssText += `\\n${override.selector} {\\n${customProperties}\\n}\\n`;\n            }\n            if ('mediaQuery' in override) {\n                cssText += `\\n@media (${override.mediaQuery}) {\n  [data-amplify-theme=\"${name}\"] {\n    ${customProperties}\n  }\n}\\n`;\n            }\n            if ('breakpoint' in override) {\n                const breakpoint = mergedTheme.breakpoints.values[override.breakpoint];\n                cssText += `\\n@media (min-width: ${breakpoint}px) {\n  [data-amplify-theme=\"${name}\"] {\n    ${customProperties}\n  }\n}\\n`;\n            }\n            if ('colorMode' in override) {\n                cssText += `\\n@media (prefers-color-scheme: ${override.colorMode}) {\n          [data-amplify-theme=\"${name}\"][data-amplify-color-mode=\"system\"] {\n            ${customProperties}\n            color-scheme: ${override.colorMode};\n          }\n        }\\n`;\n                cssText += `\\n[data-amplify-theme=\"${name}\"][data-amplify-color-mode=\"${override.colorMode}\"] {\n          ${customProperties}\n          color-scheme: ${override.colorMode};\n        }\\n`;\n            }\n            return {\n                ...override,\n                tokens,\n            };\n        });\n    }\n    return {\n        tokens,\n        breakpoints,\n        name,\n        cssText,\n        // keep overrides separate from base theme\n        // this allows web platforms to use plain CSS scoped to a\n        // selector and only override the CSS vars needed. This\n        // means we could generate CSS at build-time in a postcss\n        // plugin, or do it at runtime and inject the CSS into a\n        // style tag.\n        // This also allows RN to dynamically switch themes in a\n        // provider.\n        overrides,\n    };\n}\n\nexport { createTheme };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}