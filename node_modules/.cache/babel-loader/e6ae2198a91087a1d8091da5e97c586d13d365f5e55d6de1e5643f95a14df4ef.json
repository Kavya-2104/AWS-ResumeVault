{"ast":null,"code":"import * as React from 'react';\nimport { getConsecutiveIntArray } from '../shared/utils.mjs';\nconst ELLIPSIS = '...';\n/**\n * This hook will be used to determine the range of page numbers to be rendered,\n * including ellipsis dots(e.g., an array like [1, '...', 4, 5, 6, '...', 10]).\n * @param currentPage current page number\n * @param totalPages total number of pages\n * @param siblingCount the number of siblings on each side of\n * @returns an array that contains the range of numbers to be rendered\n */\nconst useRange = (currentPageParam, totalPagesParam, siblingCountParam = 1) => {\n  const range = React.useMemo(() => {\n    // The current page should not be less than 1\n    const currentPage = Math.max(currentPageParam, 1);\n    // The sibling count should not be less than 1\n    const siblingCount = Math.max(siblingCountParam, 1);\n    // The total pages should be always greater than current page\n    const totalPages = Math.max(currentPage, totalPagesParam);\n    // Note: 1-based index will be used for page value.\n    const firstPage = 1;\n    const lastPage = totalPages;\n    /**\n     * To avoid resizing our pagination component while a user is interacting with the component,\n     * the total number of items returned by the hook should remain constant.\n     * The consant is supposed to be the max number of items that would returned by the hook in all cases,\n     * so it should be calculated by 1(first page) + 1(last page) + 1(current page) + 2 * siblingCount + 2(ellipses)\n     */\n    const maxNumOfItems = 5 + 2 * siblingCount;\n    /**\n     * Case 1: If the total number of pages is not greater than the max number of items that would potentially be returned,\n     * then no need to run through the ellipsis cases, just simply return the range from 1 to totalPages (e.g. [1, 2, 3, 4]).\n     */\n    if (totalPages < maxNumOfItems) {\n      return getConsecutiveIntArray(1, totalPages);\n    }\n    /**\n     * Determine if ellipsis dots should be rendered on either left or right side, or both\n     */\n    const leftSiblingPage = Math.max(currentPage - siblingCount, firstPage);\n    const rightSiblingPage = Math.min(currentPage + siblingCount, lastPage);\n    const shouldRenderStartEllipsis = leftSiblingPage > 2;\n    const shouldRenderEndEllipsis = rightSiblingPage < lastPage - 1;\n    /**\n     * Case 2: Only render ellipsis dots on the left side (e.g. [1, '...', 6, 7, 8, 9, 10]).\n     */\n    if (shouldRenderStartEllipsis && !shouldRenderEndEllipsis) {\n      // 1(current page) + 1(last page) + 1(fill up a page for the position of end ellipsis) + 2 * siblingCount\n      const rightItemCount = 3 + 2 * siblingCount;\n      const rightRange = getConsecutiveIntArray(lastPage - rightItemCount + 1, lastPage);\n      return [firstPage, ELLIPSIS, ...rightRange];\n    }\n    /**\n     * Case 3: Only render ellipsis dots on the right side (e.g. [1, 2, 3, 4, 5, '...', 10]).\n     */\n    if (!shouldRenderStartEllipsis && shouldRenderEndEllipsis) {\n      // 1(current page) + 1(last page) + 1(fill up a page for the position of start ellipsis) + 2 * siblingCount\n      const leftItemCount = 3 + 2 * siblingCount;\n      const leftRange = getConsecutiveIntArray(firstPage, leftItemCount);\n      return [...leftRange, ELLIPSIS, lastPage];\n    }\n    /**\n     * Case 4: Render ellipsis on both side (e.g. [1, '...', 4, 5, 6, '...', 10]).\n     */\n    const middleRange = getConsecutiveIntArray(leftSiblingPage, rightSiblingPage);\n    return [firstPage, ELLIPSIS, ...middleRange, ELLIPSIS, lastPage];\n  }, [currentPageParam, totalPagesParam, siblingCountParam]);\n  return range;\n};\nexport { ELLIPSIS, useRange };","map":{"version":3,"names":["React","getConsecutiveIntArray","ELLIPSIS","useRange","currentPageParam","totalPagesParam","siblingCountParam","range","useMemo","currentPage","Math","max","siblingCount","totalPages","firstPage","lastPage","maxNumOfItems","leftSiblingPage","rightSiblingPage","min","shouldRenderStartEllipsis","shouldRenderEndEllipsis","rightItemCount","rightRange","leftItemCount","leftRange","middleRange"],"sources":["E:/CSC-PROJECT/amplify-react-app/node_modules/@aws-amplify/ui-react/dist/esm/primitives/Pagination/useRange.mjs"],"sourcesContent":["import * as React from 'react';\nimport { getConsecutiveIntArray } from '../shared/utils.mjs';\n\nconst ELLIPSIS = '...';\n/**\n * This hook will be used to determine the range of page numbers to be rendered,\n * including ellipsis dots(e.g., an array like [1, '...', 4, 5, 6, '...', 10]).\n * @param currentPage current page number\n * @param totalPages total number of pages\n * @param siblingCount the number of siblings on each side of\n * @returns an array that contains the range of numbers to be rendered\n */\nconst useRange = (currentPageParam, totalPagesParam, siblingCountParam = 1) => {\n    const range = React.useMemo(() => {\n        // The current page should not be less than 1\n        const currentPage = Math.max(currentPageParam, 1);\n        // The sibling count should not be less than 1\n        const siblingCount = Math.max(siblingCountParam, 1);\n        // The total pages should be always greater than current page\n        const totalPages = Math.max(currentPage, totalPagesParam);\n        // Note: 1-based index will be used for page value.\n        const firstPage = 1;\n        const lastPage = totalPages;\n        /**\n         * To avoid resizing our pagination component while a user is interacting with the component,\n         * the total number of items returned by the hook should remain constant.\n         * The consant is supposed to be the max number of items that would returned by the hook in all cases,\n         * so it should be calculated by 1(first page) + 1(last page) + 1(current page) + 2 * siblingCount + 2(ellipses)\n         */\n        const maxNumOfItems = 5 + 2 * siblingCount;\n        /**\n         * Case 1: If the total number of pages is not greater than the max number of items that would potentially be returned,\n         * then no need to run through the ellipsis cases, just simply return the range from 1 to totalPages (e.g. [1, 2, 3, 4]).\n         */\n        if (totalPages < maxNumOfItems) {\n            return getConsecutiveIntArray(1, totalPages);\n        }\n        /**\n         * Determine if ellipsis dots should be rendered on either left or right side, or both\n         */\n        const leftSiblingPage = Math.max(currentPage - siblingCount, firstPage);\n        const rightSiblingPage = Math.min(currentPage + siblingCount, lastPage);\n        const shouldRenderStartEllipsis = leftSiblingPage > 2;\n        const shouldRenderEndEllipsis = rightSiblingPage < lastPage - 1;\n        /**\n         * Case 2: Only render ellipsis dots on the left side (e.g. [1, '...', 6, 7, 8, 9, 10]).\n         */\n        if (shouldRenderStartEllipsis && !shouldRenderEndEllipsis) {\n            // 1(current page) + 1(last page) + 1(fill up a page for the position of end ellipsis) + 2 * siblingCount\n            const rightItemCount = 3 + 2 * siblingCount;\n            const rightRange = getConsecutiveIntArray(lastPage - rightItemCount + 1, lastPage);\n            return [firstPage, ELLIPSIS, ...rightRange];\n        }\n        /**\n         * Case 3: Only render ellipsis dots on the right side (e.g. [1, 2, 3, 4, 5, '...', 10]).\n         */\n        if (!shouldRenderStartEllipsis && shouldRenderEndEllipsis) {\n            // 1(current page) + 1(last page) + 1(fill up a page for the position of start ellipsis) + 2 * siblingCount\n            const leftItemCount = 3 + 2 * siblingCount;\n            const leftRange = getConsecutiveIntArray(firstPage, leftItemCount);\n            return [...leftRange, ELLIPSIS, lastPage];\n        }\n        /**\n         * Case 4: Render ellipsis on both side (e.g. [1, '...', 4, 5, 6, '...', 10]).\n         */\n        const middleRange = getConsecutiveIntArray(leftSiblingPage, rightSiblingPage);\n        return [firstPage, ELLIPSIS, ...middleRange, ELLIPSIS, lastPage];\n    }, [currentPageParam, totalPagesParam, siblingCountParam]);\n    return range;\n};\n\nexport { ELLIPSIS, useRange };\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,sBAAsB,QAAQ,qBAAqB;AAE5D,MAAMC,QAAQ,GAAG,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,QAAQ,GAAGA,CAACC,gBAAgB,EAAEC,eAAe,EAAEC,iBAAiB,GAAG,CAAC,KAAK;EAC3E,MAAMC,KAAK,GAAGP,KAAK,CAACQ,OAAO,CAAC,MAAM;IAC9B;IACA,MAAMC,WAAW,GAAGC,IAAI,CAACC,GAAG,CAACP,gBAAgB,EAAE,CAAC,CAAC;IACjD;IACA,MAAMQ,YAAY,GAAGF,IAAI,CAACC,GAAG,CAACL,iBAAiB,EAAE,CAAC,CAAC;IACnD;IACA,MAAMO,UAAU,GAAGH,IAAI,CAACC,GAAG,CAACF,WAAW,EAAEJ,eAAe,CAAC;IACzD;IACA,MAAMS,SAAS,GAAG,CAAC;IACnB,MAAMC,QAAQ,GAAGF,UAAU;IAC3B;AACR;AACA;AACA;AACA;AACA;IACQ,MAAMG,aAAa,GAAG,CAAC,GAAG,CAAC,GAAGJ,YAAY;IAC1C;AACR;AACA;AACA;IACQ,IAAIC,UAAU,GAAGG,aAAa,EAAE;MAC5B,OAAOf,sBAAsB,CAAC,CAAC,EAAEY,UAAU,CAAC;IAChD;IACA;AACR;AACA;IACQ,MAAMI,eAAe,GAAGP,IAAI,CAACC,GAAG,CAACF,WAAW,GAAGG,YAAY,EAAEE,SAAS,CAAC;IACvE,MAAMI,gBAAgB,GAAGR,IAAI,CAACS,GAAG,CAACV,WAAW,GAAGG,YAAY,EAAEG,QAAQ,CAAC;IACvE,MAAMK,yBAAyB,GAAGH,eAAe,GAAG,CAAC;IACrD,MAAMI,uBAAuB,GAAGH,gBAAgB,GAAGH,QAAQ,GAAG,CAAC;IAC/D;AACR;AACA;IACQ,IAAIK,yBAAyB,IAAI,CAACC,uBAAuB,EAAE;MACvD;MACA,MAAMC,cAAc,GAAG,CAAC,GAAG,CAAC,GAAGV,YAAY;MAC3C,MAAMW,UAAU,GAAGtB,sBAAsB,CAACc,QAAQ,GAAGO,cAAc,GAAG,CAAC,EAAEP,QAAQ,CAAC;MAClF,OAAO,CAACD,SAAS,EAAEZ,QAAQ,EAAE,GAAGqB,UAAU,CAAC;IAC/C;IACA;AACR;AACA;IACQ,IAAI,CAACH,yBAAyB,IAAIC,uBAAuB,EAAE;MACvD;MACA,MAAMG,aAAa,GAAG,CAAC,GAAG,CAAC,GAAGZ,YAAY;MAC1C,MAAMa,SAAS,GAAGxB,sBAAsB,CAACa,SAAS,EAAEU,aAAa,CAAC;MAClE,OAAO,CAAC,GAAGC,SAAS,EAAEvB,QAAQ,EAAEa,QAAQ,CAAC;IAC7C;IACA;AACR;AACA;IACQ,MAAMW,WAAW,GAAGzB,sBAAsB,CAACgB,eAAe,EAAEC,gBAAgB,CAAC;IAC7E,OAAO,CAACJ,SAAS,EAAEZ,QAAQ,EAAE,GAAGwB,WAAW,EAAExB,QAAQ,EAAEa,QAAQ,CAAC;EACpE,CAAC,EAAE,CAACX,gBAAgB,EAAEC,eAAe,EAAEC,iBAAiB,CAAC,CAAC;EAC1D,OAAOC,KAAK;AAChB,CAAC;AAED,SAASL,QAAQ,EAAEC,QAAQ"},"metadata":{},"sourceType":"module","externalDependencies":[]}