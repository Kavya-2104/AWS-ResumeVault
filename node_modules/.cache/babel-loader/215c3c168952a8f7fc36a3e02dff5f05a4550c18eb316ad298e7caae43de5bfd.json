{"ast":null,"code":"import kebabCase from 'lodash/kebabCase.js';\nimport usesReference from 'style-dictionary/lib/utils/references/usesReference.js';\nimport '@aws-amplify/core/internals/utils';\nimport '../utils/setUserAgent/constants.mjs';\nimport { isObject, has, isString } from '../utils/utils.mjs';\nconst CSS_VARIABLE_PREFIX = 'amplify';\n// Important: these properties should not be altered in\n// order to maintain the expected order of the CSS `box-shadow` property\nconst SHADOW_PROPERTIES = ['offsetX', 'offsetY', 'blurRadius', 'spreadRadius', 'color'];\nfunction referenceValue(value) {\n  if (!value) return '';\n  if (usesReference(value)) {\n    const path = value.replace(/\\{|\\}/g, '').replace('.value', '').split('.');\n    return `var(--${cssNameTransform({\n      path\n    })})`;\n  }\n  return value;\n}\nfunction cssValue(token) {\n  const {\n    value\n  } = token;\n  if (isString(value)) {\n    return referenceValue(value);\n  }\n  if (isShadowTokenObject(value)) {\n    return SHADOW_PROPERTIES.map(property => {\n      return referenceValue(\n      // lookup property against `token` first for custom non-nested value, then lookup\n      // property against `value` for design token value\n      isShadowTokenObject(token) ? token[property] : value[property]);\n    }).join(' ');\n  }\n  return value;\n}\nfunction cssNameTransform({\n  path = []\n}) {\n  return `${kebabCase([CSS_VARIABLE_PREFIX, ...path].join(' '))}`;\n}\n/**\n * Helper function to test if something is a design token or not.\n * Used in the React component style props.\n *\n * @param value - thing to test if it is a design token or not\n * @returns boolean\n */\nfunction isDesignToken(value) {\n  return isObject(value) && has(value, 'value');\n}\nfunction isShadowTokenObject(value) {\n  return isObject(value) && has(value, 'offsetX');\n}\n/**\n * Recursive function that will walk down the token object\n * and perform the setupToken function on each token.\n * Similar to what Style Dictionary does.\n */\nfunction setupTokens({\n  tokens,\n  path = [],\n  setupToken\n}) {\n  if (has(tokens, 'value')) {\n    return setupToken({\n      token: tokens,\n      path\n    });\n  }\n  const output = {};\n  for (const name in tokens) {\n    if (has(tokens, name)) {\n      const value = tokens[name];\n      const nextTokens = isObject(value) ? value : {\n        value\n      };\n      output[name] = setupTokens({\n        tokens: nextTokens,\n        path: path.concat(name),\n        setupToken\n      });\n    }\n  }\n  return output;\n}\nexport { CSS_VARIABLE_PREFIX, cssNameTransform, cssValue, isDesignToken, isShadowTokenObject, setupTokens };","map":{"version":3,"names":["kebabCase","usesReference","isObject","has","isString","CSS_VARIABLE_PREFIX","SHADOW_PROPERTIES","referenceValue","value","path","replace","split","cssNameTransform","cssValue","token","isShadowTokenObject","map","property","join","isDesignToken","setupTokens","tokens","setupToken","output","name","nextTokens","concat"],"sources":["E:/CSC-PROJECT/amplify-react-app/node_modules/@aws-amplify/ui/dist/esm/theme/utils.mjs"],"sourcesContent":["import kebabCase from 'lodash/kebabCase.js';\nimport usesReference from 'style-dictionary/lib/utils/references/usesReference.js';\nimport '@aws-amplify/core/internals/utils';\nimport '../utils/setUserAgent/constants.mjs';\nimport { isObject, has, isString } from '../utils/utils.mjs';\n\nconst CSS_VARIABLE_PREFIX = 'amplify';\n// Important: these properties should not be altered in\n// order to maintain the expected order of the CSS `box-shadow` property\nconst SHADOW_PROPERTIES = [\n    'offsetX',\n    'offsetY',\n    'blurRadius',\n    'spreadRadius',\n    'color',\n];\nfunction referenceValue(value) {\n    if (!value)\n        return '';\n    if (usesReference(value)) {\n        const path = value.replace(/\\{|\\}/g, '').replace('.value', '').split('.');\n        return `var(--${cssNameTransform({ path })})`;\n    }\n    return value;\n}\nfunction cssValue(token) {\n    const { value } = token;\n    if (isString(value)) {\n        return referenceValue(value);\n    }\n    if (isShadowTokenObject(value)) {\n        return SHADOW_PROPERTIES.map((property) => {\n            return referenceValue(\n            // lookup property against `token` first for custom non-nested value, then lookup\n            // property against `value` for design token value\n            isShadowTokenObject(token) ? token[property] : value[property]);\n        }).join(' ');\n    }\n    return value;\n}\nfunction cssNameTransform({ path = [] }) {\n    return `${kebabCase([CSS_VARIABLE_PREFIX, ...path].join(' '))}`;\n}\n/**\n * Helper function to test if something is a design token or not.\n * Used in the React component style props.\n *\n * @param value - thing to test if it is a design token or not\n * @returns boolean\n */\nfunction isDesignToken(value) {\n    return isObject(value) && has(value, 'value');\n}\nfunction isShadowTokenObject(value) {\n    return isObject(value) && has(value, 'offsetX');\n}\n/**\n * Recursive function that will walk down the token object\n * and perform the setupToken function on each token.\n * Similar to what Style Dictionary does.\n */\nfunction setupTokens({ tokens, path = [], setupToken, }) {\n    if (has(tokens, 'value')) {\n        return setupToken({ token: tokens, path });\n    }\n    const output = {};\n    for (const name in tokens) {\n        if (has(tokens, name)) {\n            const value = tokens[name];\n            const nextTokens = isObject(value) ? value : { value };\n            output[name] = setupTokens({\n                tokens: nextTokens,\n                path: path.concat(name),\n                setupToken,\n            });\n        }\n    }\n    return output;\n}\n\nexport { CSS_VARIABLE_PREFIX, cssNameTransform, cssValue, isDesignToken, isShadowTokenObject, setupTokens };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}