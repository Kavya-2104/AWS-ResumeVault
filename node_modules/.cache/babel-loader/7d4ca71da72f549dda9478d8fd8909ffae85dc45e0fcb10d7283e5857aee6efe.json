{"ast":null,"code":"import { ConsoleLogger } from '../../../Logger/ConsoleLogger.mjs';\nimport '../../../utils/getClientInfo/getClientInfo.mjs';\nimport '../../../utils/retry/retry.mjs';\nimport '@aws-crypto/sha256-js';\nimport '@smithy/util-hex-encoding';\nimport '../../../awsClients/pinpoint/base.mjs';\nimport { putEvents } from '../../../awsClients/pinpoint/putEvents.mjs';\nimport { isAppInForeground } from './isAppInForeground.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('PinpointEventBuffer');\nconst RETRYABLE_CODES = [429, 500];\nconst ACCEPTED_CODES = [202];\nclass PinpointEventBuffer {\n  constructor(config) {\n    this._interval = undefined;\n    this._pause = false;\n    this._flush = false;\n    this._buffer = [];\n    this._config = config;\n    this._sendBatch = this._sendBatch.bind(this);\n    this._startLoop();\n  }\n  push(event) {\n    if (this._buffer.length >= this._config.bufferSize) {\n      logger.debug('Exceeded Pinpoint event buffer limits, event dropped.', {\n        eventId: event.eventId\n      });\n      return;\n    }\n    this._buffer.push({\n      [event.eventId]: event\n    });\n  }\n  pause() {\n    this._pause = true;\n  }\n  resume() {\n    this._pause = false;\n  }\n  flush() {\n    this._flush = true;\n  }\n  identityHasChanged(identityId) {\n    return this._config.identityId !== identityId;\n  }\n  flushAll() {\n    this._putEvents(this._buffer.splice(0, this._buffer.length));\n  }\n  _startLoop() {\n    if (this._interval) {\n      clearInterval(this._interval);\n    }\n    const {\n      flushInterval\n    } = this._config;\n    this._interval = setInterval(this._sendBatch, flushInterval);\n  }\n  _sendBatch() {\n    const bufferLength = this._buffer.length;\n    if (this._flush && !bufferLength && this._interval) {\n      clearInterval(this._interval);\n    }\n    if (this._pause || !bufferLength || !isAppInForeground()) {\n      return;\n    }\n    const {\n      flushSize\n    } = this._config;\n    const batchSize = Math.min(flushSize, bufferLength);\n    const bufferSubset = this._buffer.splice(0, batchSize);\n    this._putEvents(bufferSubset);\n  }\n  async _putEvents(buffer) {\n    const eventMap = this._bufferToMap(buffer);\n    const batchEventParams = this._generateBatchEventParams(eventMap);\n    try {\n      const {\n        credentials,\n        region,\n        userAgentValue\n      } = this._config;\n      const data = await putEvents({\n        credentials,\n        region,\n        userAgentValue\n      }, batchEventParams);\n      this._processPutEventsSuccessResponse(data, eventMap);\n    } catch (err) {\n      return this._handlePutEventsFailure(err, eventMap);\n    }\n  }\n  _generateBatchEventParams(eventMap) {\n    const batchItem = {};\n    Object.values(eventMap).forEach(item => {\n      const {\n        event,\n        timestamp,\n        endpointId,\n        eventId,\n        session\n      } = item;\n      const {\n        name,\n        attributes,\n        metrics\n      } = event;\n      batchItem[endpointId] = {\n        Endpoint: {\n          ...batchItem[endpointId]?.Endpoint\n        },\n        Events: {\n          ...batchItem[endpointId]?.Events,\n          [eventId]: {\n            EventType: name,\n            Timestamp: new Date(timestamp).toISOString(),\n            Attributes: attributes,\n            Metrics: metrics,\n            Session: session\n          }\n        }\n      };\n    });\n    return {\n      ApplicationId: this._config.appId,\n      EventsRequest: {\n        BatchItem: batchItem\n      }\n    };\n  }\n  _handlePutEventsFailure(err, eventMap) {\n    logger.debug('putEvents call to Pinpoint failed.', err);\n    const statusCode = err.$metadata && err.$metadata.httpStatusCode;\n    if (RETRYABLE_CODES.includes(statusCode)) {\n      const retryableEvents = Object.values(eventMap);\n      this._retry(retryableEvents);\n      return;\n    }\n  }\n  _processPutEventsSuccessResponse(data, eventMap) {\n    const {\n      Results = {}\n    } = data.EventsResponse ?? {};\n    const retryableEvents = [];\n    Object.entries(Results).forEach(([endpointId, endpointValues]) => {\n      const responses = endpointValues.EventsItemResponse ?? {};\n      Object.entries(responses).forEach(([eventId, eventValues]) => {\n        const eventObject = eventMap[eventId];\n        if (!eventObject) {\n          return;\n        }\n        const {\n          StatusCode,\n          Message\n        } = eventValues ?? {};\n        if (StatusCode && ACCEPTED_CODES.includes(StatusCode)) {\n          return;\n        }\n        if (StatusCode && RETRYABLE_CODES.includes(StatusCode)) {\n          retryableEvents.push(eventObject);\n          return;\n        }\n        const {\n          name\n        } = eventObject.event;\n        logger.warn('Pinpoint event failed to send.', {\n          eventId,\n          name,\n          message: Message\n        });\n      });\n    });\n    if (retryableEvents.length) {\n      this._retry(retryableEvents);\n    }\n  }\n  _retry(retryableEvents) {\n    // retryable events that haven't reached the resendLimit\n    const eligibleEvents = [];\n    retryableEvents.forEach(bufferedEvent => {\n      const {\n        eventId\n      } = bufferedEvent;\n      const {\n        name\n      } = bufferedEvent.event;\n      if (bufferedEvent.resendLimit-- > 0) {\n        logger.debug('Resending event.', {\n          eventId,\n          name,\n          remainingAttempts: bufferedEvent.resendLimit\n        });\n        eligibleEvents.push({\n          [eventId]: bufferedEvent\n        });\n        return;\n      }\n      logger.debug('No retry attempts remaining for event.', {\n        eventId,\n        name\n      });\n    });\n    // add the events to the front of the buffer\n    this._buffer.unshift(...eligibleEvents);\n  }\n  _bufferToMap(buffer) {\n    return buffer.reduce((acc, curVal) => {\n      const [[key, value]] = Object.entries(curVal);\n      acc[key] = value;\n      return acc;\n    }, {});\n  }\n}\nexport { PinpointEventBuffer };","map":{"version":3,"names":["logger","ConsoleLogger","RETRYABLE_CODES","ACCEPTED_CODES","PinpointEventBuffer","constructor","config","_interval","undefined","_pause","_flush","_buffer","_config","_sendBatch","bind","_startLoop","push","event","length","bufferSize","debug","eventId","pause","resume","flush","identityHasChanged","identityId","flushAll","_putEvents","splice","clearInterval","flushInterval","setInterval","bufferLength","isAppInForeground","flushSize","batchSize","Math","min","bufferSubset","buffer","eventMap","_bufferToMap","batchEventParams","_generateBatchEventParams","credentials","region","userAgentValue","data","putEvents","_processPutEventsSuccessResponse","err","_handlePutEventsFailure","batchItem","Object","values","forEach","item","timestamp","endpointId","session","name","attributes","metrics","Endpoint","Events","EventType","Timestamp","Date","toISOString","Attributes","Metrics","Session","ApplicationId","appId","EventsRequest","BatchItem","statusCode","$metadata","httpStatusCode","includes","retryableEvents","_retry","Results","EventsResponse","entries","endpointValues","responses","EventsItemResponse","eventValues","eventObject","StatusCode","Message","warn","message","eligibleEvents","bufferedEvent","resendLimit","remainingAttempts","unshift","reduce","acc","curVal","key","value"],"sources":["E:\\CSC-PROJECT\\amplify-react-app\\node_modules\\@aws-amplify\\core\\src\\providers\\pinpoint\\utils\\PinpointEventBuffer.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ConsoleLogger } from '../../../Logger';\nimport { putEvents, } from '../../../awsClients/pinpoint';\nimport { isAppInForeground } from './isAppInForeground';\nconst logger = new ConsoleLogger('PinpointEventBuffer');\nconst RETRYABLE_CODES = [429, 500];\nconst ACCEPTED_CODES = [202];\nexport class PinpointEventBuffer {\n    constructor(config) {\n        this._interval = undefined;\n        this._pause = false;\n        this._flush = false;\n        this._buffer = [];\n        this._config = config;\n        this._sendBatch = this._sendBatch.bind(this);\n        this._startLoop();\n    }\n    push(event) {\n        if (this._buffer.length >= this._config.bufferSize) {\n            logger.debug('Exceeded Pinpoint event buffer limits, event dropped.', {\n                eventId: event.eventId,\n            });\n            return;\n        }\n        this._buffer.push({ [event.eventId]: event });\n    }\n    pause() {\n        this._pause = true;\n    }\n    resume() {\n        this._pause = false;\n    }\n    flush() {\n        this._flush = true;\n    }\n    identityHasChanged(identityId) {\n        return this._config.identityId !== identityId;\n    }\n    flushAll() {\n        this._putEvents(this._buffer.splice(0, this._buffer.length));\n    }\n    _startLoop() {\n        if (this._interval) {\n            clearInterval(this._interval);\n        }\n        const { flushInterval } = this._config;\n        this._interval = setInterval(this._sendBatch, flushInterval);\n    }\n    _sendBatch() {\n        const bufferLength = this._buffer.length;\n        if (this._flush && !bufferLength && this._interval) {\n            clearInterval(this._interval);\n        }\n        if (this._pause || !bufferLength || !isAppInForeground()) {\n            return;\n        }\n        const { flushSize } = this._config;\n        const batchSize = Math.min(flushSize, bufferLength);\n        const bufferSubset = this._buffer.splice(0, batchSize);\n        this._putEvents(bufferSubset);\n    }\n    async _putEvents(buffer) {\n        const eventMap = this._bufferToMap(buffer);\n        const batchEventParams = this._generateBatchEventParams(eventMap);\n        try {\n            const { credentials, region, userAgentValue } = this._config;\n            const data = await putEvents({\n                credentials,\n                region,\n                userAgentValue,\n            }, batchEventParams);\n            this._processPutEventsSuccessResponse(data, eventMap);\n        }\n        catch (err) {\n            return this._handlePutEventsFailure(err, eventMap);\n        }\n    }\n    _generateBatchEventParams(eventMap) {\n        const batchItem = {};\n        Object.values(eventMap).forEach(item => {\n            const { event, timestamp, endpointId, eventId, session } = item;\n            const { name, attributes, metrics } = event;\n            batchItem[endpointId] = {\n                Endpoint: {\n                    ...batchItem[endpointId]?.Endpoint,\n                },\n                Events: {\n                    ...batchItem[endpointId]?.Events,\n                    [eventId]: {\n                        EventType: name,\n                        Timestamp: new Date(timestamp).toISOString(),\n                        Attributes: attributes,\n                        Metrics: metrics,\n                        Session: session,\n                    },\n                },\n            };\n        });\n        return {\n            ApplicationId: this._config.appId,\n            EventsRequest: {\n                BatchItem: batchItem,\n            },\n        };\n    }\n    _handlePutEventsFailure(err, eventMap) {\n        logger.debug('putEvents call to Pinpoint failed.', err);\n        const statusCode = err.$metadata && err.$metadata.httpStatusCode;\n        if (RETRYABLE_CODES.includes(statusCode)) {\n            const retryableEvents = Object.values(eventMap);\n            this._retry(retryableEvents);\n            return;\n        }\n    }\n    _processPutEventsSuccessResponse(data, eventMap) {\n        const { Results = {} } = data.EventsResponse ?? {};\n        const retryableEvents = [];\n        Object.entries(Results).forEach(([endpointId, endpointValues]) => {\n            const responses = endpointValues.EventsItemResponse ?? {};\n            Object.entries(responses).forEach(([eventId, eventValues]) => {\n                const eventObject = eventMap[eventId];\n                if (!eventObject) {\n                    return;\n                }\n                const { StatusCode, Message } = eventValues ?? {};\n                // manually crafting handlers response to keep API consistant\n                const response = {\n                    EventsResponse: {\n                        Results: {\n                            [endpointId]: {\n                                EventsItemResponse: {\n                                    [eventId]: { StatusCode, Message },\n                                },\n                            },\n                        },\n                    },\n                };\n                if (StatusCode && ACCEPTED_CODES.includes(StatusCode)) {\n                    return;\n                }\n                if (StatusCode && RETRYABLE_CODES.includes(StatusCode)) {\n                    retryableEvents.push(eventObject);\n                    return;\n                }\n                const { name } = eventObject.event;\n                logger.warn('Pinpoint event failed to send.', {\n                    eventId,\n                    name,\n                    message: Message,\n                });\n            });\n        });\n        if (retryableEvents.length) {\n            this._retry(retryableEvents);\n        }\n    }\n    _retry(retryableEvents) {\n        // retryable events that haven't reached the resendLimit\n        const eligibleEvents = [];\n        retryableEvents.forEach((bufferedEvent) => {\n            const { eventId } = bufferedEvent;\n            const { name } = bufferedEvent.event;\n            if (bufferedEvent.resendLimit-- > 0) {\n                logger.debug('Resending event.', {\n                    eventId,\n                    name,\n                    remainingAttempts: bufferedEvent.resendLimit,\n                });\n                eligibleEvents.push({ [eventId]: bufferedEvent });\n                return;\n            }\n            logger.debug('No retry attempts remaining for event.', {\n                eventId,\n                name,\n            });\n        });\n        // add the events to the front of the buffer\n        this._buffer.unshift(...eligibleEvents);\n    }\n    _bufferToMap(buffer) {\n        return buffer.reduce((acc, curVal) => {\n            const [[key, value]] = Object.entries(curVal);\n            acc[key] = value;\n            return acc;\n        }, {});\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}