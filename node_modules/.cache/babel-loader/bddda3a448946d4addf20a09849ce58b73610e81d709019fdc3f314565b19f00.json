{"ast":null,"code":"import { AuthError } from '../../../../../errors/AuthError.mjs';\nimport { textEncoder } from '../../textEncoder/index.mjs';\nimport BigInteger from '../BigInteger/BigInteger.mjs';\nimport { calculateS } from '../calculate/calculateS.mjs';\nimport { calculateU } from '../calculate/calculateU.mjs';\nimport { getBytesFromHex } from '../getBytesFromHex.mjs';\nimport { getHashFromData } from '../getHashFromData.mjs';\nimport { getHashFromHex } from '../getHashFromHex.mjs';\nimport { getHexFromBytes } from '../getHexFromBytes.mjs';\nimport { getHkdfKey } from '../getHkdfKey.mjs';\nimport { getPaddedHex } from '../getPaddedHex.mjs';\nimport { getRandomBytes } from '../getRandomBytes.mjs';\nimport { getRandomString } from '../getRandomString.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n/** @class */\nclass AuthenticationHelper {\n  constructor({\n    userPoolName,\n    a,\n    g,\n    A,\n    N\n  }) {\n    this.encoder = textEncoder;\n    this.userPoolName = userPoolName;\n    this.a = a;\n    this.g = g;\n    this.A = A;\n    this.N = N;\n    this.k = new BigInteger(getHashFromHex(`${getPaddedHex(N)}${getPaddedHex(g)}`), 16);\n  }\n  /**\n   * @returns {string} Generated random value included in password hash.\n   */\n  getRandomPassword() {\n    if (!this.randomPassword) {\n      throw new AuthError({\n        name: 'EmptyBigIntegerRandomPassword',\n        message: 'random password is empty'\n      });\n    }\n    return this.randomPassword;\n  }\n  /**\n   * @returns {string} Generated random value included in devices hash.\n   */\n  getSaltToHashDevices() {\n    if (!this.saltToHashDevices) {\n      throw new AuthError({\n        name: 'EmptyBigIntegersaltToHashDevices',\n        message: 'saltToHashDevices is empty'\n      });\n    }\n    return this.saltToHashDevices;\n  }\n  /**\n   * @returns {string} Value used to verify devices.\n   */\n  getVerifierDevices() {\n    if (!this.verifierDevices) {\n      throw new AuthError({\n        name: 'EmptyBigIntegerVerifierDevices',\n        message: 'verifyDevices is empty'\n      });\n    }\n    return this.verifierDevices;\n  }\n  /**\n   * Generate salts and compute verifier.\n   *\n   * @param {string} deviceGroupKey Devices to generate verifier for.\n   * @param {string} username User to generate verifier for.\n   *\n   * @returns {Promise<void>}\n   */\n  async generateHashDevice(deviceGroupKey, username) {\n    this.randomPassword = getRandomString();\n    const combinedString = `${deviceGroupKey}${username}:${this.randomPassword}`;\n    const hashedString = getHashFromData(combinedString);\n    const hexRandom = getHexFromBytes(getRandomBytes(16));\n    // The random hex will be unambiguously represented as a postive integer\n    this.saltToHashDevices = getPaddedHex(new BigInteger(hexRandom, 16));\n    return new Promise((resolve, reject) => {\n      this.g.modPow(new BigInteger(getHashFromHex(this.saltToHashDevices + hashedString), 16), this.N, (err, result) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        this.verifierDevices = getPaddedHex(result);\n        resolve();\n      });\n    });\n  }\n  /**\n   * Calculates the final HKDF key based on computed S value, computed U value and the key\n   *\n   * @param {String} username Username.\n   * @param {String} password Password.\n   * @param {AuthBigInteger} B Server B value.\n   * @param {AuthBigInteger} salt Generated salt.\n   */\n  async getPasswordAuthenticationKey({\n    username,\n    password,\n    serverBValue,\n    salt\n  }) {\n    if (serverBValue.mod(this.N).equals(BigInteger.ZERO)) {\n      throw new Error('B cannot be zero.');\n    }\n    const U = calculateU({\n      A: this.A,\n      B: serverBValue\n    });\n    const usernamePassword = `${this.userPoolName}${username}:${password}`;\n    const usernamePasswordHash = getHashFromData(usernamePassword);\n    const x = new BigInteger(getHashFromHex(getPaddedHex(salt) + usernamePasswordHash), 16);\n    const S = await calculateS({\n      a: this.a,\n      g: this.g,\n      k: this.k,\n      x,\n      B: serverBValue,\n      N: this.N,\n      U\n    });\n    const context = this.encoder.convert('Caldera Derived Key');\n    const spacer = this.encoder.convert(String.fromCharCode(1));\n    const info = new Uint8Array(context.byteLength + spacer.byteLength);\n    info.set(context, 0);\n    info.set(spacer, context.byteLength);\n    const hkdfKey = getHkdfKey(getBytesFromHex(getPaddedHex(S)), getBytesFromHex(getPaddedHex(U)), info);\n    return hkdfKey;\n  }\n}\nexport { AuthenticationHelper as default };","map":{"version":3,"names":["AuthenticationHelper","constructor","userPoolName","a","g","A","N","encoder","textEncoder","k","BigInteger","getHashFromHex","getPaddedHex","getRandomPassword","randomPassword","AuthError","name","message","getSaltToHashDevices","saltToHashDevices","getVerifierDevices","verifierDevices","generateHashDevice","deviceGroupKey","username","getRandomString","combinedString","hashedString","getHashFromData","hexRandom","getHexFromBytes","getRandomBytes","Promise","resolve","reject","modPow","err","result","getPasswordAuthenticationKey","password","serverBValue","salt","mod","equals","ZERO","Error","U","calculateU","B","usernamePassword","usernamePasswordHash","x","S","calculateS","context","convert","spacer","String","fromCharCode","info","Uint8Array","byteLength","set","hkdfKey","getHkdfKey","getBytesFromHex"],"sources":["E:\\CSC-PROJECT\\amplify-react-app\\node_modules\\@aws-amplify\\auth\\src\\providers\\cognito\\utils\\srp\\AuthenticationHelper\\AuthenticationHelper.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { AuthError } from '../../../../../errors/AuthError';\nimport { textEncoder } from '../../textEncoder';\nimport { BigInteger } from '../BigInteger';\nimport { calculateS, calculateU } from '../calculate';\nimport { getBytesFromHex } from '../getBytesFromHex';\nimport { getHashFromData } from '../getHashFromData';\nimport { getHashFromHex } from '../getHashFromHex';\nimport { getHexFromBytes } from '../getHexFromBytes';\nimport { getHkdfKey } from '../getHkdfKey';\nimport { getPaddedHex } from '../getPaddedHex';\nimport { getRandomBytes } from '../getRandomBytes';\nimport { getRandomString } from '../getRandomString';\n/** @class */\nexport default class AuthenticationHelper {\n    constructor({ userPoolName, a, g, A, N, }) {\n        this.encoder = textEncoder;\n        this.userPoolName = userPoolName;\n        this.a = a;\n        this.g = g;\n        this.A = A;\n        this.N = N;\n        this.k = new BigInteger(getHashFromHex(`${getPaddedHex(N)}${getPaddedHex(g)}`), 16);\n    }\n    /**\n     * @returns {string} Generated random value included in password hash.\n     */\n    getRandomPassword() {\n        if (!this.randomPassword) {\n            throw new AuthError({\n                name: 'EmptyBigIntegerRandomPassword',\n                message: 'random password is empty',\n            });\n        }\n        return this.randomPassword;\n    }\n    /**\n     * @returns {string} Generated random value included in devices hash.\n     */\n    getSaltToHashDevices() {\n        if (!this.saltToHashDevices) {\n            throw new AuthError({\n                name: 'EmptyBigIntegersaltToHashDevices',\n                message: 'saltToHashDevices is empty',\n            });\n        }\n        return this.saltToHashDevices;\n    }\n    /**\n     * @returns {string} Value used to verify devices.\n     */\n    getVerifierDevices() {\n        if (!this.verifierDevices) {\n            throw new AuthError({\n                name: 'EmptyBigIntegerVerifierDevices',\n                message: 'verifyDevices is empty',\n            });\n        }\n        return this.verifierDevices;\n    }\n    /**\n     * Generate salts and compute verifier.\n     *\n     * @param {string} deviceGroupKey Devices to generate verifier for.\n     * @param {string} username User to generate verifier for.\n     *\n     * @returns {Promise<void>}\n     */\n    async generateHashDevice(deviceGroupKey, username) {\n        this.randomPassword = getRandomString();\n        const combinedString = `${deviceGroupKey}${username}:${this.randomPassword}`;\n        const hashedString = getHashFromData(combinedString);\n        const hexRandom = getHexFromBytes(getRandomBytes(16));\n        // The random hex will be unambiguously represented as a postive integer\n        this.saltToHashDevices = getPaddedHex(new BigInteger(hexRandom, 16));\n        return new Promise((resolve, reject) => {\n            this.g.modPow(new BigInteger(getHashFromHex(this.saltToHashDevices + hashedString), 16), this.N, (err, result) => {\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                this.verifierDevices = getPaddedHex(result);\n                resolve();\n            });\n        });\n    }\n    /**\n     * Calculates the final HKDF key based on computed S value, computed U value and the key\n     *\n     * @param {String} username Username.\n     * @param {String} password Password.\n     * @param {AuthBigInteger} B Server B value.\n     * @param {AuthBigInteger} salt Generated salt.\n     */\n    async getPasswordAuthenticationKey({ username, password, serverBValue, salt, }) {\n        if (serverBValue.mod(this.N).equals(BigInteger.ZERO)) {\n            throw new Error('B cannot be zero.');\n        }\n        const U = calculateU({\n            A: this.A,\n            B: serverBValue,\n        });\n        const usernamePassword = `${this.userPoolName}${username}:${password}`;\n        const usernamePasswordHash = getHashFromData(usernamePassword);\n        const x = new BigInteger(getHashFromHex(getPaddedHex(salt) + usernamePasswordHash), 16);\n        const S = await calculateS({\n            a: this.a,\n            g: this.g,\n            k: this.k,\n            x,\n            B: serverBValue,\n            N: this.N,\n            U,\n        });\n        const context = this.encoder.convert('Caldera Derived Key');\n        const spacer = this.encoder.convert(String.fromCharCode(1));\n        const info = new Uint8Array(context.byteLength + spacer.byteLength);\n        info.set(context, 0);\n        info.set(spacer, context.byteLength);\n        const hkdfKey = getHkdfKey(getBytesFromHex(getPaddedHex(S)), getBytesFromHex(getPaddedHex(U)), info);\n        return hkdfKey;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}