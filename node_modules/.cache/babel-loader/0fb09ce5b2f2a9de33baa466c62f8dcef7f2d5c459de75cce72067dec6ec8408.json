{"ast":null,"code":"import { Framework } from './types.mjs';\nimport { detect } from './detection/index.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n// We want to cache detection since the framework won't change\nlet frameworkCache;\nconst frameworkChangeObservers = [];\n// Setup the detection reset tracking / timeout delays\nlet resetTriggered = false;\nconst SSR_RESET_TIMEOUT = 10; // ms\nconst WEB_RESET_TIMEOUT = 10; // ms\nconst PRIME_FRAMEWORK_DELAY = 1000; // ms\nconst detectFramework = () => {\n  if (!frameworkCache) {\n    frameworkCache = detect();\n    if (resetTriggered) {\n      // The final run of detectFramework:\n      // Starting from this point, the `frameworkCache` becomes \"final\".\n      // So we don't need to notify the observers again so the observer\n      // can be removed after the final notice.\n      while (frameworkChangeObservers.length) {\n        frameworkChangeObservers.pop()?.();\n      }\n    } else {\n      // The first run of detectFramework:\n      // Every time we update the cache, call each observer function\n      frameworkChangeObservers.forEach(fcn => {\n        fcn();\n      });\n    }\n    // Retry once for either Unknown type after a delay (explained below)\n    resetTimeout(Framework.ServerSideUnknown, SSR_RESET_TIMEOUT);\n    resetTimeout(Framework.WebUnknown, WEB_RESET_TIMEOUT);\n  }\n  return frameworkCache;\n};\n/**\n * @internal Setup observer callback that will be called everytime the framework changes\n */\nconst observeFrameworkChanges = fcn => {\n  // When the `frameworkCache` won't be updated again, we ignore all incoming\n  // observers.\n  if (resetTriggered) {\n    return;\n  }\n  frameworkChangeObservers.push(fcn);\n};\nfunction clearCache() {\n  frameworkCache = undefined;\n}\n// For a framework type and a delay amount, setup the event to re-detect\n//   During the runtime boot, it is possible that framework detection will\n//   be triggered before the framework has made modifications to the\n//   global/window/etc needed for detection. When no framework is detected\n//   we will reset and try again to ensure we don't use a cached\n//   non-framework detection result for all requests.\nfunction resetTimeout(framework, delay) {\n  if (frameworkCache === framework && !resetTriggered) {\n    setTimeout(() => {\n      clearCache();\n      resetTriggered = true;\n      setTimeout(detectFramework, PRIME_FRAMEWORK_DELAY);\n    }, delay);\n  }\n}\nexport { clearCache, detectFramework, frameworkChangeObservers, observeFrameworkChanges };","map":{"version":3,"names":["frameworkCache","frameworkChangeObservers","resetTriggered","SSR_RESET_TIMEOUT","WEB_RESET_TIMEOUT","PRIME_FRAMEWORK_DELAY","detectFramework","detect","length","pop","forEach","fcn","resetTimeout","Framework","ServerSideUnknown","WebUnknown","observeFrameworkChanges","push","clearCache","undefined","framework","delay","setTimeout"],"sources":["E:\\CSC-PROJECT\\amplify-react-app\\node_modules\\@aws-amplify\\core\\src\\Platform\\detectFramework.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Framework } from './types';\nimport { detect } from './detection';\n// We want to cache detection since the framework won't change\nlet frameworkCache;\nexport const frameworkChangeObservers = [];\n// Setup the detection reset tracking / timeout delays\nlet resetTriggered = false;\nconst SSR_RESET_TIMEOUT = 10; // ms\nconst WEB_RESET_TIMEOUT = 10; // ms\nconst PRIME_FRAMEWORK_DELAY = 1000; // ms\nexport const detectFramework = () => {\n    if (!frameworkCache) {\n        frameworkCache = detect();\n        if (resetTriggered) {\n            // The final run of detectFramework:\n            // Starting from this point, the `frameworkCache` becomes \"final\".\n            // So we don't need to notify the observers again so the observer\n            // can be removed after the final notice.\n            while (frameworkChangeObservers.length) {\n                frameworkChangeObservers.pop()?.();\n            }\n        }\n        else {\n            // The first run of detectFramework:\n            // Every time we update the cache, call each observer function\n            frameworkChangeObservers.forEach(fcn => {\n                fcn();\n            });\n        }\n        // Retry once for either Unknown type after a delay (explained below)\n        resetTimeout(Framework.ServerSideUnknown, SSR_RESET_TIMEOUT);\n        resetTimeout(Framework.WebUnknown, WEB_RESET_TIMEOUT);\n    }\n    return frameworkCache;\n};\n/**\n * @internal Setup observer callback that will be called everytime the framework changes\n */\nexport const observeFrameworkChanges = (fcn) => {\n    // When the `frameworkCache` won't be updated again, we ignore all incoming\n    // observers.\n    if (resetTriggered) {\n        return;\n    }\n    frameworkChangeObservers.push(fcn);\n};\nexport function clearCache() {\n    frameworkCache = undefined;\n}\n// For a framework type and a delay amount, setup the event to re-detect\n//   During the runtime boot, it is possible that framework detection will\n//   be triggered before the framework has made modifications to the\n//   global/window/etc needed for detection. When no framework is detected\n//   we will reset and try again to ensure we don't use a cached\n//   non-framework detection result for all requests.\nfunction resetTimeout(framework, delay) {\n    if (frameworkCache === framework && !resetTriggered) {\n        setTimeout(() => {\n            clearCache();\n            resetTriggered = true;\n            setTimeout(detectFramework, PRIME_FRAMEWORK_DELAY);\n        }, delay);\n    }\n}\n"],"mappings":";;;AAAA;AACA;AAGA;AACA,IAAIA,cAAc;AACN,MAACC,wBAAwB,GAAG;AACxC;AACA,IAAIC,cAAc,GAAG,KAAK;AAC1B,MAAMC,iBAAiB,GAAG,EAAE,CAAC;AAC7B,MAAMC,iBAAiB,GAAG,EAAE,CAAC;AAC7B,MAAMC,qBAAqB,GAAG,IAAI,CAAC;AACvB,MAACC,eAAe,GAAGA,CAAA,KAAM;EACjC,IAAI,CAACN,cAAc,EAAE;IACjBA,cAAc,GAAGO,MAAM,EAAE;IACzB,IAAIL,cAAc,EAAE;MAC5B;MACA;MACA;MACA;MACY,OAAOD,wBAAwB,CAACO,MAAM,EAAE;QACpCP,wBAAwB,CAACQ,GAAG,EAAE,IAAI;MAClD;IACA,CAAS,MACI;MACb;MACA;MACYR,wBAAwB,CAACS,OAAO,CAACC,GAAG,IAAI;QACpCA,GAAG,EAAE;MACrB,CAAa,CAAC;IACd;IACA;IACQC,YAAY,CAACC,SAAS,CAACC,iBAAiB,EAAEX,iBAAiB,CAAC;IAC5DS,YAAY,CAACC,SAAS,CAACE,UAAU,EAAEX,iBAAiB,CAAC;EAC7D;EACI,OAAOJ,cAAc;AACzB;AACA;AACA;AACA;AACY,MAACgB,uBAAuB,GAAIL,GAAG,IAAK;EAChD;EACA;EACI,IAAIT,cAAc,EAAE;IAChB;EACR;EACID,wBAAwB,CAACgB,IAAI,CAACN,GAAG,CAAC;AACtC;AACO,SAASO,UAAUA,CAAA,EAAG;EACzBlB,cAAc,GAAGmB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASP,YAAYA,CAACQ,SAAS,EAAEC,KAAK,EAAE;EACpC,IAAIrB,cAAc,KAAKoB,SAAS,IAAI,CAAClB,cAAc,EAAE;IACjDoB,UAAU,CAAC,MAAM;MACbJ,UAAU,EAAE;MACZhB,cAAc,GAAG,IAAI;MACrBoB,UAAU,CAAChB,eAAe,EAAED,qBAAqB,CAAC;IAC9D,CAAS,EAAEgB,KAAK,CAAC;EACjB;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}