{"ast":null,"code":"import { BackgroundManagerNotOpenError } from './BackgroundManagerNotOpenError.mjs';\nimport { BackgroundProcessManagerState } from './types.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n/**\n * @private For internal Amplify use.\n *\n * Creates a new scope for promises, observables, and other types of work or\n * processes that may be running in the background. This manager provides\n * an singular entrypoint to request termination and await completion.\n *\n * As work completes on its own prior to close, the manager removes them\n * from the registry to avoid holding references to completed jobs.\n */\nclass BackgroundProcessManager {\n  /**\n   * Creates a new manager for promises, observables, and other types\n   * of work that may be running in the background. This manager provides\n   * a centralized mechanism to request termination and await completion.\n   */\n  constructor() {\n    /**\n     * A string indicating whether the manager is accepting new work (\"Open\"),\n     * waiting for work to complete (\"Closing\"), or fully done with all\n     * submitted work and *not* accepting new jobs (\"Closed\").\n     */\n    this._state = BackgroundProcessManagerState.Open;\n    /**\n     * The list of outstanding jobs we'll need to wait for upon `close()`\n     */\n    this.jobs = new Set();\n  }\n  add(jobOrDescription, optionalDescription) {\n    let job;\n    let description;\n    if (typeof jobOrDescription === 'string') {\n      job = undefined;\n      description = jobOrDescription;\n    } else {\n      job = jobOrDescription;\n      description = optionalDescription;\n    }\n    const error = this.closedFailure(description);\n    if (error) return error;\n    if (job === undefined) {\n      return this.addHook(description);\n    } else if (typeof job === 'function') {\n      return this.addFunction(job, description);\n    } else if (job instanceof BackgroundProcessManager) {\n      return this.addManager(job, description);\n    } else {\n      throw new Error('If `job` is provided, it must be an Observable, Function, or BackgroundProcessManager.');\n    }\n  }\n  /**\n   * Adds a **cleaner** function that doesn't immediately get executed.\n   * Instead, the caller gets a **terminate** function back. The *cleaner* is\n   * invoked only once the mananger *closes* or the returned **terminate**\n   * function is called.\n   *\n   * @param clean The cleanup function.\n   * @param description Optional description to help identify pending jobs.\n   * @returns A terminate function.\n   */\n  addCleaner(clean, description) {\n    const {\n      resolve,\n      onTerminate\n    } = this.addHook(description);\n    const proxy = async () => {\n      await clean();\n      resolve();\n    };\n    onTerminate.then(proxy);\n    return proxy;\n  }\n  addFunction(job, description) {\n    // the function we call when we want to try to terminate this job.\n    let terminate;\n    // the promise the job can opt into listening to for termination.\n    const onTerminate = new Promise(resolve => {\n      terminate = resolve;\n    });\n    // finally! start the job.\n    const jobResult = job(onTerminate);\n    // depending on what the job gives back, register the result\n    // so we can monitor for completion.\n    if (typeof jobResult?.then === 'function') {\n      this.registerPromise(jobResult, terminate, description);\n    }\n    // At the end of the day, or you know, method call, it doesn't matter\n    // what the return value is at all; we just pass it through to the\n    // caller.\n    return jobResult;\n  }\n  addManager(manager, description) {\n    this.addCleaner(async () => await manager.close(), description);\n  }\n  /**\n   * Creates and registers a fabricated job for processes that need to operate\n   * with callbacks/hooks. The returned `resolve` and `reject`\n   * functions can be used to signal the job is done successfully or not.\n   * The returned `onTerminate` is a promise that will resolve when the\n   * manager is requesting the termination of the job.\n   *\n   * @param description Optional description to help identify pending jobs.\n   * @returns `{ resolve, reject, onTerminate }`\n   */\n  addHook(description) {\n    // the resolve/reject functions we'll provide to the caller to signal\n    // the state of the job.\n    let resolve;\n    let reject;\n    // the underlying promise we'll use to manage it, pretty much like\n    // any other promise.\n    const promise = new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n    // the function we call when we want to try to terminate this job.\n    let terminate;\n    // the promise the job can opt into listening to for termination.\n    const onTerminate = new Promise(resolveTerminate => {\n      terminate = resolveTerminate;\n    });\n    this.registerPromise(promise, terminate, description);\n    return {\n      resolve,\n      reject,\n      onTerminate\n    };\n  }\n  /**\n   * Adds a Promise based job to the list of jobs for monitoring and listens\n   * for either a success or failure, upon which the job is considered \"done\"\n   * and removed from the registry.\n   *\n   * @param promise A promise that is on its way to being returned to a\n   * caller, which needs to be tracked as a background job.\n   * @param terminate The termination function to register, which can be\n   * invoked to request the job stop.\n   * @param description Optional description to help identify pending jobs.\n   */\n  registerPromise(promise, terminate, description) {\n    const jobEntry = {\n      promise,\n      terminate,\n      description\n    };\n    this.jobs.add(jobEntry);\n    // in all of my testing, it is safe to multi-subscribe to a promise.\n    // so, rather than create another layer of promising, we're just going\n    // to hook into the promise we already have, and when it's done\n    // (successfully or not), we no longer need to wait for it upon close.\n    //\n    // sorry this is a bit hand-wavy:\n    //\n    // i believe we use `.then` and `.catch` instead of `.finally` because\n    // `.finally` is invoked in a different order in the sequence, and this\n    // breaks assumptions throughout and causes failures.\n    promise.then(() => {\n      this.jobs.delete(jobEntry);\n    }).catch(() => {\n      this.jobs.delete(jobEntry);\n    });\n  }\n  /**\n   * The number of jobs being waited on.\n   *\n   * We don't use this for anything. It's just informational for the caller,\n   * and can be used in logging and testing.\n   *\n   * @returns the number of jobs.\n   */\n  get length() {\n    return this.jobs.size;\n  }\n  /**\n   * The execution state of the manager. One of:\n   *\n   * 1. \"Open\" -> Accepting new jobs\n   * 1. \"Closing\" -> Not accepting new work. Waiting for jobs to complete.\n   * 1. \"Closed\" -> Not accepting new work. All submitted jobs are complete.\n   */\n  get state() {\n    return this._state;\n  }\n  /**\n   * The registered `description` of all still-pending jobs.\n   *\n   * @returns descriptions as an array.\n   */\n  get pending() {\n    return Array.from(this.jobs).map(job => job.description);\n  }\n  /**\n   * Whether the manager is accepting new jobs.\n   */\n  get isOpen() {\n    return this._state === BackgroundProcessManagerState.Open;\n  }\n  /**\n   * Whether the manager is rejecting new work, but still waiting for\n   * submitted work to complete.\n   */\n  get isClosing() {\n    return this._state === BackgroundProcessManagerState.Closing;\n  }\n  /**\n   * Whether the manager is rejecting work and done waiting for submitted\n   * work to complete.\n   */\n  get isClosed() {\n    return this._state === BackgroundProcessManagerState.Closed;\n  }\n  closedFailure(description) {\n    if (!this.isOpen) {\n      return Promise.reject(new BackgroundManagerNotOpenError([`The manager is ${this.state}.`, `You tried to add \"${description}\".`, `Pending jobs: [\\n${this.pending.map(t => '    ' + t).join(',\\n')}\\n]`].join('\\n')));\n    }\n  }\n  /**\n   * Signals jobs to stop (for those that accept interruptions) and waits\n   * for confirmation that jobs have stopped.\n   *\n   * This immediately puts the manager into a closing state and just begins\n   * to reject new work. After all work in the manager is complete, the\n   * manager goes into a `Completed` state and `close()` returns.\n   *\n   * This call is idempotent.\n   *\n   * If the manager is already closing or closed, `finalCleaup` is not executed.\n   *\n   * @param onClosed\n   * @returns The settled results of each still-running job's promise. If the\n   * manager is already closed, this will contain the results as of when the\n   * manager's `close()` was called in an `Open` state.\n   */\n  async close() {\n    if (this.isOpen) {\n      this._state = BackgroundProcessManagerState.Closing;\n      for (const job of Array.from(this.jobs)) {\n        try {\n          job.terminate();\n        } catch (error) {\n          // Due to potential races with a job's natural completion, it's\n          // reasonable to expect the termination call to fail. Hence,\n          // not logging as an error.\n          console.warn(`Failed to send termination signal to job. Error: ${error.message}`, job);\n        }\n      }\n      // Use `allSettled()` because we want to wait for all to finish. We do\n      // not want to stop waiting if there is a failure.\n      this._closingPromise = Promise.allSettled(Array.from(this.jobs).map(j => j.promise));\n      await this._closingPromise;\n      this._state = BackgroundProcessManagerState.Closed;\n    }\n    return this._closingPromise;\n  }\n  /**\n   * Signals the manager to start accepting work (again) and returns once\n   * the manager is ready to do so.\n   *\n   * If the state is already `Open`, this call is a no-op.\n   *\n   * If the state is `Closed`, this call simply updates state and returns.\n   *\n   * If the state is `Closing`, this call waits for completion before it\n   * updates the state and returns.\n   */\n  async open() {\n    if (this.isClosing) {\n      await this.close();\n    }\n    this._state = BackgroundProcessManagerState.Open;\n  }\n}\nexport { BackgroundProcessManager };","map":{"version":3,"names":["BackgroundProcessManager","constructor","_state","BackgroundProcessManagerState","Open","jobs","Set","add","jobOrDescription","optionalDescription","job","description","undefined","error","closedFailure","addHook","addFunction","addManager","Error","addCleaner","clean","resolve","onTerminate","proxy","then","terminate","Promise","jobResult","registerPromise","manager","close","reject","promise","res","rej","resolveTerminate","jobEntry","delete","catch","length","size","state","pending","Array","from","map","isOpen","isClosing","Closing","isClosed","Closed","BackgroundManagerNotOpenError","t","join","console","warn","message","_closingPromise","allSettled","j","open"],"sources":["E:\\CSC-PROJECT\\amplify-react-app\\node_modules\\@aws-amplify\\core\\src\\BackgroundProcessManager\\BackgroundProcessManager.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { BackgroundManagerNotOpenError } from './BackgroundManagerNotOpenError';\nimport { BackgroundProcessManagerState } from './types';\n/**\n * @private For internal Amplify use.\n *\n * Creates a new scope for promises, observables, and other types of work or\n * processes that may be running in the background. This manager provides\n * an singular entrypoint to request termination and await completion.\n *\n * As work completes on its own prior to close, the manager removes them\n * from the registry to avoid holding references to completed jobs.\n */\nexport class BackgroundProcessManager {\n    /**\n     * Creates a new manager for promises, observables, and other types\n     * of work that may be running in the background. This manager provides\n     * a centralized mechanism to request termination and await completion.\n     */\n    constructor() {\n        /**\n         * A string indicating whether the manager is accepting new work (\"Open\"),\n         * waiting for work to complete (\"Closing\"), or fully done with all\n         * submitted work and *not* accepting new jobs (\"Closed\").\n         */\n        this._state = BackgroundProcessManagerState.Open;\n        /**\n         * The list of outstanding jobs we'll need to wait for upon `close()`\n         */\n        this.jobs = new Set();\n    }\n    add(jobOrDescription, optionalDescription) {\n        let job;\n        let description;\n        if (typeof jobOrDescription === 'string') {\n            job = undefined;\n            description = jobOrDescription;\n        }\n        else {\n            job = jobOrDescription;\n            description = optionalDescription;\n        }\n        const error = this.closedFailure(description);\n        if (error)\n            return error;\n        if (job === undefined) {\n            return this.addHook(description);\n        }\n        else if (typeof job === 'function') {\n            return this.addFunction(job, description);\n        }\n        else if (job instanceof BackgroundProcessManager) {\n            return this.addManager(job, description);\n        }\n        else {\n            throw new Error('If `job` is provided, it must be an Observable, Function, or BackgroundProcessManager.');\n        }\n    }\n    /**\n     * Adds a **cleaner** function that doesn't immediately get executed.\n     * Instead, the caller gets a **terminate** function back. The *cleaner* is\n     * invoked only once the mananger *closes* or the returned **terminate**\n     * function is called.\n     *\n     * @param clean The cleanup function.\n     * @param description Optional description to help identify pending jobs.\n     * @returns A terminate function.\n     */\n    addCleaner(clean, description) {\n        const { resolve, onTerminate } = this.addHook(description);\n        const proxy = async () => {\n            await clean();\n            resolve();\n        };\n        onTerminate.then(proxy);\n        return proxy;\n    }\n    addFunction(job, description) {\n        // the function we call when we want to try to terminate this job.\n        let terminate;\n        // the promise the job can opt into listening to for termination.\n        const onTerminate = new Promise(resolve => {\n            terminate = resolve;\n        });\n        // finally! start the job.\n        const jobResult = job(onTerminate);\n        // depending on what the job gives back, register the result\n        // so we can monitor for completion.\n        if (typeof jobResult?.then === 'function') {\n            this.registerPromise(jobResult, terminate, description);\n        }\n        // At the end of the day, or you know, method call, it doesn't matter\n        // what the return value is at all; we just pass it through to the\n        // caller.\n        return jobResult;\n    }\n    addManager(manager, description) {\n        this.addCleaner(async () => await manager.close(), description);\n    }\n    /**\n     * Creates and registers a fabricated job for processes that need to operate\n     * with callbacks/hooks. The returned `resolve` and `reject`\n     * functions can be used to signal the job is done successfully or not.\n     * The returned `onTerminate` is a promise that will resolve when the\n     * manager is requesting the termination of the job.\n     *\n     * @param description Optional description to help identify pending jobs.\n     * @returns `{ resolve, reject, onTerminate }`\n     */\n    addHook(description) {\n        // the resolve/reject functions we'll provide to the caller to signal\n        // the state of the job.\n        let resolve;\n        let reject;\n        // the underlying promise we'll use to manage it, pretty much like\n        // any other promise.\n        const promise = new Promise((res, rej) => {\n            resolve = res;\n            reject = rej;\n        });\n        // the function we call when we want to try to terminate this job.\n        let terminate;\n        // the promise the job can opt into listening to for termination.\n        const onTerminate = new Promise(resolveTerminate => {\n            terminate = resolveTerminate;\n        });\n        this.registerPromise(promise, terminate, description);\n        return {\n            resolve,\n            reject,\n            onTerminate,\n        };\n    }\n    /**\n     * Adds a Promise based job to the list of jobs for monitoring and listens\n     * for either a success or failure, upon which the job is considered \"done\"\n     * and removed from the registry.\n     *\n     * @param promise A promise that is on its way to being returned to a\n     * caller, which needs to be tracked as a background job.\n     * @param terminate The termination function to register, which can be\n     * invoked to request the job stop.\n     * @param description Optional description to help identify pending jobs.\n     */\n    registerPromise(promise, terminate, description) {\n        const jobEntry = { promise, terminate, description };\n        this.jobs.add(jobEntry);\n        // in all of my testing, it is safe to multi-subscribe to a promise.\n        // so, rather than create another layer of promising, we're just going\n        // to hook into the promise we already have, and when it's done\n        // (successfully or not), we no longer need to wait for it upon close.\n        //\n        // sorry this is a bit hand-wavy:\n        //\n        // i believe we use `.then` and `.catch` instead of `.finally` because\n        // `.finally` is invoked in a different order in the sequence, and this\n        // breaks assumptions throughout and causes failures.\n        promise\n            .then(() => {\n            this.jobs.delete(jobEntry);\n        })\n            .catch(() => {\n            this.jobs.delete(jobEntry);\n        });\n    }\n    /**\n     * The number of jobs being waited on.\n     *\n     * We don't use this for anything. It's just informational for the caller,\n     * and can be used in logging and testing.\n     *\n     * @returns the number of jobs.\n     */\n    get length() {\n        return this.jobs.size;\n    }\n    /**\n     * The execution state of the manager. One of:\n     *\n     * 1. \"Open\" -> Accepting new jobs\n     * 1. \"Closing\" -> Not accepting new work. Waiting for jobs to complete.\n     * 1. \"Closed\" -> Not accepting new work. All submitted jobs are complete.\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * The registered `description` of all still-pending jobs.\n     *\n     * @returns descriptions as an array.\n     */\n    get pending() {\n        return Array.from(this.jobs).map(job => job.description);\n    }\n    /**\n     * Whether the manager is accepting new jobs.\n     */\n    get isOpen() {\n        return this._state === BackgroundProcessManagerState.Open;\n    }\n    /**\n     * Whether the manager is rejecting new work, but still waiting for\n     * submitted work to complete.\n     */\n    get isClosing() {\n        return this._state === BackgroundProcessManagerState.Closing;\n    }\n    /**\n     * Whether the manager is rejecting work and done waiting for submitted\n     * work to complete.\n     */\n    get isClosed() {\n        return this._state === BackgroundProcessManagerState.Closed;\n    }\n    closedFailure(description) {\n        if (!this.isOpen) {\n            return Promise.reject(new BackgroundManagerNotOpenError([\n                `The manager is ${this.state}.`,\n                `You tried to add \"${description}\".`,\n                `Pending jobs: [\\n${this.pending\n                    .map(t => '    ' + t)\n                    .join(',\\n')}\\n]`,\n            ].join('\\n')));\n        }\n    }\n    /**\n     * Signals jobs to stop (for those that accept interruptions) and waits\n     * for confirmation that jobs have stopped.\n     *\n     * This immediately puts the manager into a closing state and just begins\n     * to reject new work. After all work in the manager is complete, the\n     * manager goes into a `Completed` state and `close()` returns.\n     *\n     * This call is idempotent.\n     *\n     * If the manager is already closing or closed, `finalCleaup` is not executed.\n     *\n     * @param onClosed\n     * @returns The settled results of each still-running job's promise. If the\n     * manager is already closed, this will contain the results as of when the\n     * manager's `close()` was called in an `Open` state.\n     */\n    async close() {\n        if (this.isOpen) {\n            this._state = BackgroundProcessManagerState.Closing;\n            for (const job of Array.from(this.jobs)) {\n                try {\n                    job.terminate();\n                }\n                catch (error) {\n                    // Due to potential races with a job's natural completion, it's\n                    // reasonable to expect the termination call to fail. Hence,\n                    // not logging as an error.\n                    console.warn(`Failed to send termination signal to job. Error: ${error.message}`, job);\n                }\n            }\n            // Use `allSettled()` because we want to wait for all to finish. We do\n            // not want to stop waiting if there is a failure.\n            this._closingPromise = Promise.allSettled(Array.from(this.jobs).map(j => j.promise));\n            await this._closingPromise;\n            this._state = BackgroundProcessManagerState.Closed;\n        }\n        return this._closingPromise;\n    }\n    /**\n     * Signals the manager to start accepting work (again) and returns once\n     * the manager is ready to do so.\n     *\n     * If the state is already `Open`, this call is a no-op.\n     *\n     * If the state is `Closed`, this call simply updates state and returns.\n     *\n     * If the state is `Closing`, this call waits for completion before it\n     * updates the state and returns.\n     */\n    async open() {\n        if (this.isClosing) {\n            await this.close();\n        }\n        this._state = BackgroundProcessManagerState.Open;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}