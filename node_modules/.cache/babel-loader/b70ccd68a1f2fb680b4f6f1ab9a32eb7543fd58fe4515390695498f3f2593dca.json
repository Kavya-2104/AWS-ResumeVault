{"ast":null,"code":"import { withMemoization } from '@aws-amplify/core/internals/aws-client-utils';\nimport { ConsoleLogger } from '@aws-amplify/core';\nimport { NETWORK_ERROR_MESSAGE, ABORT_ERROR_MESSAGE, NETWORK_ERROR_CODE, ABORT_ERROR_CODE, CANCELED_ERROR_CODE, CANCELED_ERROR_MESSAGE } from './constants.mjs';\nimport { CanceledError } from '../../../../../errors/CanceledError.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('xhr-http-handler');\n/**\n * Base transfer handler implementation using XMLHttpRequest to support upload and download progress events.\n *\n * @param request - The request object.\n * @param options - The request options.\n * @returns A promise that will be resolved with the response object.\n *\n * @internal\n */\nconst xhrTransferHandler = (request, options) => {\n  const {\n    url,\n    method,\n    headers,\n    body\n  } = request;\n  const {\n    onDownloadProgress,\n    onUploadProgress,\n    responseType,\n    abortSignal\n  } = options;\n  return new Promise((resolve, reject) => {\n    let xhr = new XMLHttpRequest();\n    xhr.open(method.toUpperCase(), url.toString());\n    Object.entries(headers).filter(([header]) => !FORBIDDEN_HEADERS.includes(header)).forEach(([header, value]) => {\n      xhr.setRequestHeader(header, value);\n    });\n    xhr.responseType = responseType;\n    if (onDownloadProgress) {\n      xhr.addEventListener('progress', event => {\n        onDownloadProgress(convertToTransferProgressEvent(event));\n        logger.debug(event);\n      });\n    }\n    if (onUploadProgress) {\n      xhr.upload.addEventListener('progress', event => {\n        onUploadProgress(convertToTransferProgressEvent(event));\n        logger.debug(event);\n      });\n    }\n    xhr.addEventListener('error', () => {\n      const networkError = buildHandlerError(NETWORK_ERROR_MESSAGE, NETWORK_ERROR_CODE);\n      logger.error(NETWORK_ERROR_MESSAGE);\n      reject(networkError);\n      xhr = null; // clean up request\n    });\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    xhr.addEventListener('abort', () => {\n      // The abort event can be triggered after the error or load event. So we need to check if the xhr is null.\n      // When request is aborted by AbortSignal, the promise is rejected in the abortSignal's 'abort' event listener.\n      if (!xhr || abortSignal?.aborted) return;\n      // Handle abort request caused by browser instead of AbortController\n      // see: https://github.com/axios/axios/issues/537\n      const error = buildHandlerError(ABORT_ERROR_MESSAGE, ABORT_ERROR_CODE);\n      logger.error(ABORT_ERROR_MESSAGE);\n      reject(error);\n      xhr = null; // clean up request\n    });\n    // Skip handling timeout error since we don't have a timeout\n    xhr.addEventListener('readystatechange', () => {\n      if (!xhr || xhr.readyState !== xhr.DONE) {\n        return;\n      }\n      const onloadend = () => {\n        // The load event is triggered after the error/abort/load event. So we need to check if the xhr is null.\n        if (!xhr) return;\n        const responseHeaders = convertResponseHeaders(xhr.getAllResponseHeaders());\n        const responseType = xhr.responseType;\n        const responseBlob = xhr.response;\n        const responseText = responseType === 'text' ? xhr.responseText : '';\n        const bodyMixIn = {\n          blob: () => Promise.resolve(responseBlob),\n          text: withMemoization(() => responseType === 'blob' ? readBlobAsText(responseBlob) : Promise.resolve(responseText)),\n          json: () => Promise.reject(\n          // S3 does not support JSON response. So fail-fast here with nicer error message.\n          new Error('Parsing response to JSON is not implemented. Please use response.text() instead.'))\n        };\n        const response = {\n          statusCode: xhr.status,\n          headers: responseHeaders,\n          // The xhr.responseType is only set to 'blob' for streaming binary S3 object data. The streaming data is\n          // exposed via public interface of Storage.get(). So we need to return the response as a Blob object for\n          // backward compatibility. In other cases, the response payload is only used internally, we return it is\n          // {@link ResponseBodyMixin}\n          body: xhr.responseType === 'blob' ? Object.assign(responseBlob, bodyMixIn) : bodyMixIn\n        };\n        resolve(response);\n        xhr = null; // clean up request\n      };\n      // readystate handler is calling before onerror or ontimeout handlers,\n      // so we should call onloadend on the next 'tick'\n      // @see https://github.com/axios/axios/blob/9588fcdec8aca45c3ba2f7968988a5d03f23168c/lib/adapters/xhr.js#L98-L99\n      setTimeout(onloadend);\n    });\n    if (abortSignal) {\n      const onCanceled = () => {\n        // The abort event is triggered after the error or load event. So we need to check if the xhr is null.\n        if (!xhr) {\n          return;\n        }\n        const canceledError = new CanceledError({\n          name: CANCELED_ERROR_CODE,\n          message: CANCELED_ERROR_MESSAGE\n        });\n        reject(canceledError);\n        xhr.abort();\n        xhr = null;\n      };\n      abortSignal.aborted ? onCanceled() : abortSignal.addEventListener('abort', onCanceled);\n    }\n    if (typeof ReadableStream === 'function' && body instanceof ReadableStream) {\n      // This does not matter as previous implementation uses Axios which does not support ReadableStream anyway.\n      throw new Error('ReadableStream request payload is not supported.');\n    }\n    xhr.send(body ?? null);\n  });\n};\nconst convertToTransferProgressEvent = event => ({\n  transferredBytes: event.loaded,\n  totalBytes: event.lengthComputable ? event.total : undefined\n});\nconst buildHandlerError = (message, name) => {\n  const error = new Error(message);\n  error.name = name;\n  return error;\n};\n/**\n * Convert xhr.getAllResponseHeaders() string to a Record<string, string>. Note that modern browser already returns\n * header names in lowercase.\n * @param xhrHeaders - string of headers returned from xhr.getAllResponseHeaders()\n */\nconst convertResponseHeaders = xhrHeaders => {\n  if (!xhrHeaders) {\n    return {};\n  }\n  return xhrHeaders.split('\\r\\n').reduce((headerMap, line) => {\n    const parts = line.split(': ');\n    const header = parts.shift();\n    const value = parts.join(': ');\n    headerMap[header.toLowerCase()] = value;\n    return headerMap;\n  }, {});\n};\nconst readBlobAsText = blob => {\n  const reader = new FileReader();\n  return new Promise((resolve, reject) => {\n    reader.onloadend = () => {\n      if (reader.readyState !== FileReader.DONE) {\n        return;\n      }\n      resolve(reader.result);\n    };\n    reader.onerror = () => {\n      reject(reader.error);\n    };\n    reader.readAsText(blob);\n  });\n};\n// To add more forbidden headers as found set by S3. Intentionally NOT list all of them here to save bundle size.\n// https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\nconst FORBIDDEN_HEADERS = ['host'];\nexport { xhrTransferHandler };","map":{"version":3,"names":["logger","ConsoleLogger","xhrTransferHandler","request","options","url","method","headers","body","onDownloadProgress","onUploadProgress","responseType","abortSignal","Promise","resolve","reject","xhr","XMLHttpRequest","open","toUpperCase","toString","Object","entries","filter","header","FORBIDDEN_HEADERS","includes","forEach","value","setRequestHeader","addEventListener","event","convertToTransferProgressEvent","debug","upload","networkError","buildHandlerError","NETWORK_ERROR_MESSAGE","NETWORK_ERROR_CODE","error","aborted","ABORT_ERROR_MESSAGE","ABORT_ERROR_CODE","readyState","DONE","onloadend","responseHeaders","convertResponseHeaders","getAllResponseHeaders","responseBlob","response","responseText","bodyMixIn","blob","text","withMemoization","readBlobAsText","json","Error","statusCode","status","assign","setTimeout","onCanceled","canceledError","CanceledError","name","CANCELED_ERROR_CODE","message","CANCELED_ERROR_MESSAGE","abort","ReadableStream","send","transferredBytes","loaded","totalBytes","lengthComputable","total","undefined","xhrHeaders","split","reduce","headerMap","line","parts","shift","join","toLowerCase","reader","FileReader","result","onerror","readAsText"],"sources":["E:\\CSC-PROJECT\\amplify-react-app\\node_modules\\@aws-amplify\\storage\\src\\providers\\s3\\utils\\client\\runtime\\xhrTransferHandler.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { withMemoization, } from '@aws-amplify/core/internals/aws-client-utils';\nimport { ConsoleLogger } from '@aws-amplify/core';\nimport { ABORT_ERROR_CODE, ABORT_ERROR_MESSAGE, CANCELED_ERROR_CODE, CANCELED_ERROR_MESSAGE, NETWORK_ERROR_CODE, NETWORK_ERROR_MESSAGE, } from './constants';\nimport { CanceledError } from '../../../../../errors/CanceledError';\nconst logger = new ConsoleLogger('xhr-http-handler');\n/**\n * Base transfer handler implementation using XMLHttpRequest to support upload and download progress events.\n *\n * @param request - The request object.\n * @param options - The request options.\n * @returns A promise that will be resolved with the response object.\n *\n * @internal\n */\nexport const xhrTransferHandler = (request, options) => {\n    const { url, method, headers, body } = request;\n    const { onDownloadProgress, onUploadProgress, responseType, abortSignal } = options;\n    return new Promise((resolve, reject) => {\n        let xhr = new XMLHttpRequest();\n        xhr.open(method.toUpperCase(), url.toString());\n        Object.entries(headers)\n            .filter(([header]) => !FORBIDDEN_HEADERS.includes(header))\n            .forEach(([header, value]) => {\n            xhr.setRequestHeader(header, value);\n        });\n        xhr.responseType = responseType;\n        if (onDownloadProgress) {\n            xhr.addEventListener('progress', event => {\n                onDownloadProgress(convertToTransferProgressEvent(event));\n                logger.debug(event);\n            });\n        }\n        if (onUploadProgress) {\n            xhr.upload.addEventListener('progress', event => {\n                onUploadProgress(convertToTransferProgressEvent(event));\n                logger.debug(event);\n            });\n        }\n        xhr.addEventListener('error', () => {\n            const networkError = buildHandlerError(NETWORK_ERROR_MESSAGE, NETWORK_ERROR_CODE);\n            logger.error(NETWORK_ERROR_MESSAGE);\n            reject(networkError);\n            xhr = null; // clean up request\n        });\n        // Handle browser request cancellation (as opposed to a manual cancellation)\n        xhr.addEventListener('abort', () => {\n            // The abort event can be triggered after the error or load event. So we need to check if the xhr is null.\n            // When request is aborted by AbortSignal, the promise is rejected in the abortSignal's 'abort' event listener.\n            if (!xhr || abortSignal?.aborted)\n                return;\n            // Handle abort request caused by browser instead of AbortController\n            // see: https://github.com/axios/axios/issues/537\n            const error = buildHandlerError(ABORT_ERROR_MESSAGE, ABORT_ERROR_CODE);\n            logger.error(ABORT_ERROR_MESSAGE);\n            reject(error);\n            xhr = null; // clean up request\n        });\n        // Skip handling timeout error since we don't have a timeout\n        xhr.addEventListener('readystatechange', () => {\n            if (!xhr || xhr.readyState !== xhr.DONE) {\n                return;\n            }\n            const onloadend = () => {\n                // The load event is triggered after the error/abort/load event. So we need to check if the xhr is null.\n                if (!xhr)\n                    return;\n                const responseHeaders = convertResponseHeaders(xhr.getAllResponseHeaders());\n                const responseType = xhr.responseType;\n                const responseBlob = xhr.response;\n                const responseText = responseType === 'text' ? xhr.responseText : '';\n                const bodyMixIn = {\n                    blob: () => Promise.resolve(responseBlob),\n                    text: withMemoization(() => responseType === 'blob'\n                        ? readBlobAsText(responseBlob)\n                        : Promise.resolve(responseText)),\n                    json: () => Promise.reject(\n                    // S3 does not support JSON response. So fail-fast here with nicer error message.\n                    new Error('Parsing response to JSON is not implemented. Please use response.text() instead.')),\n                };\n                const response = {\n                    statusCode: xhr.status,\n                    headers: responseHeaders,\n                    // The xhr.responseType is only set to 'blob' for streaming binary S3 object data. The streaming data is\n                    // exposed via public interface of Storage.get(). So we need to return the response as a Blob object for\n                    // backward compatibility. In other cases, the response payload is only used internally, we return it is\n                    // {@link ResponseBodyMixin}\n                    body: (xhr.responseType === 'blob'\n                        ? Object.assign(responseBlob, bodyMixIn)\n                        : bodyMixIn),\n                };\n                resolve(response);\n                xhr = null; // clean up request\n            };\n            // readystate handler is calling before onerror or ontimeout handlers,\n            // so we should call onloadend on the next 'tick'\n            // @see https://github.com/axios/axios/blob/9588fcdec8aca45c3ba2f7968988a5d03f23168c/lib/adapters/xhr.js#L98-L99\n            setTimeout(onloadend);\n        });\n        if (abortSignal) {\n            const onCanceled = () => {\n                // The abort event is triggered after the error or load event. So we need to check if the xhr is null.\n                if (!xhr) {\n                    return;\n                }\n                const canceledError = new CanceledError({\n                    name: CANCELED_ERROR_CODE,\n                    message: CANCELED_ERROR_MESSAGE,\n                });\n                reject(canceledError);\n                xhr.abort();\n                xhr = null;\n            };\n            abortSignal.aborted\n                ? onCanceled()\n                : abortSignal.addEventListener('abort', onCanceled);\n        }\n        if (typeof ReadableStream === 'function' &&\n            body instanceof ReadableStream) {\n            // This does not matter as previous implementation uses Axios which does not support ReadableStream anyway.\n            throw new Error('ReadableStream request payload is not supported.');\n        }\n        xhr.send(body ?? null);\n    });\n};\nconst convertToTransferProgressEvent = (event) => ({\n    transferredBytes: event.loaded,\n    totalBytes: event.lengthComputable ? event.total : undefined,\n});\nconst buildHandlerError = (message, name) => {\n    const error = new Error(message);\n    error.name = name;\n    return error;\n};\n/**\n * Convert xhr.getAllResponseHeaders() string to a Record<string, string>. Note that modern browser already returns\n * header names in lowercase.\n * @param xhrHeaders - string of headers returned from xhr.getAllResponseHeaders()\n */\nconst convertResponseHeaders = (xhrHeaders) => {\n    if (!xhrHeaders) {\n        return {};\n    }\n    return xhrHeaders\n        .split('\\r\\n')\n        .reduce((headerMap, line) => {\n        const parts = line.split(': ');\n        const header = parts.shift();\n        const value = parts.join(': ');\n        headerMap[header.toLowerCase()] = value;\n        return headerMap;\n    }, {});\n};\nconst readBlobAsText = (blob) => {\n    const reader = new FileReader();\n    return new Promise((resolve, reject) => {\n        reader.onloadend = () => {\n            if (reader.readyState !== FileReader.DONE) {\n                return;\n            }\n            resolve(reader.result);\n        };\n        reader.onerror = () => {\n            reject(reader.error);\n        };\n        reader.readAsText(blob);\n    });\n};\n// To add more forbidden headers as found set by S3. Intentionally NOT list all of them here to save bundle size.\n// https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\nconst FORBIDDEN_HEADERS = ['host'];\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}