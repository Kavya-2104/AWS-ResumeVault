{"ast":null,"code":"import { ConsoleLogger } from '../Logger/ConsoleLogger.mjs';\nimport { defaultConfig, currentSizeKey } from './constants.mjs';\nimport { getCurrentSizeKey, getCurrentTime, getByteLength } from './utils/cacheHelpers.mjs';\nimport { assert, CacheErrorCode } from './utils/errorHelpers.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('StorageCache');\n/**\n * Initialization of the cache\n *\n */\nclass StorageCacheCommon {\n  /**\n   * Initialize the cache\n   *\n   * @param config - Custom configuration for this instance.\n   */\n  constructor({\n    config,\n    keyValueStorage\n  }) {\n    this.config = {\n      ...defaultConfig,\n      ...config\n    };\n    this.keyValueStorage = keyValueStorage;\n    this.sanitizeConfig();\n  }\n  getModuleName() {\n    return 'Cache';\n  }\n  /**\n   * Set custom configuration for the cache instance.\n   *\n   * @param config - customized configuration (without keyPrefix, which can't be changed)\n   *\n   * @return - the current configuration\n   */\n  configure(config) {\n    if (config) {\n      if (config.keyPrefix) {\n        logger.warn('keyPrefix can not be re-configured on an existing Cache instance.');\n      }\n      this.config = {\n        ...this.config,\n        ...config\n      };\n    }\n    this.sanitizeConfig();\n    return this.config;\n  }\n  /**\n   * return the current size of the cache\n   * @return {Promise}\n   */\n  async getCurrentCacheSize() {\n    let size = await this.getStorage().getItem(getCurrentSizeKey(this.config.keyPrefix));\n    if (!size) {\n      await this.getStorage().setItem(getCurrentSizeKey(this.config.keyPrefix), '0');\n      size = '0';\n    }\n    return Number(size);\n  }\n  /**\n   * Set item into cache. You can put number, string, boolean or object.\n   * The cache will first check whether has the same key.\n   * If it has, it will delete the old item and then put the new item in\n   * The cache will pop out items if it is full\n   * You can specify the cache item options. The cache will abort and output a warning:\n   * If the key is invalid\n   * If the size of the item exceeds itemMaxSize.\n   * If the value is undefined\n   * If incorrect cache item configuration\n   * If error happened with browser storage\n   *\n   * @param {String} key - the key of the item\n   * @param {Object} value - the value of the item\n   * @param {Object} [options] - optional, the specified meta-data\n   *\n   * @return {Promise}\n   */\n  async setItem(key, value, options) {\n    logger.debug(`Set item: key is ${key}, value is ${value} with options: ${options}`);\n    if (!key || key === currentSizeKey) {\n      logger.warn(`Invalid key: should not be empty or reserved key: '${currentSizeKey}'`);\n      return;\n    }\n    if (typeof value === 'undefined') {\n      logger.warn(`The value of item should not be undefined!`);\n      return;\n    }\n    const cacheItemOptions = {\n      priority: options?.priority !== undefined ? options.priority : this.config.defaultPriority,\n      expires: options?.expires !== undefined ? options.expires : this.config.defaultTTL + getCurrentTime()\n    };\n    if (cacheItemOptions.priority < 1 || cacheItemOptions.priority > 5) {\n      logger.warn(`Invalid parameter: priority due to out or range. It should be within 1 and 5.`);\n      return;\n    }\n    const prefixedKey = `${this.config.keyPrefix}${key}`;\n    const item = this.fillCacheItem(prefixedKey, value, cacheItemOptions);\n    // check whether this item is too big;\n    if (item.byteSize > this.config.itemMaxSize) {\n      logger.warn(`Item with key: ${key} you are trying to put into is too big!`);\n      return;\n    }\n    try {\n      // first look into the storage, if it exists, delete it.\n      const val = await this.getStorage().getItem(prefixedKey);\n      if (val) {\n        await this.removeCacheItem(prefixedKey, JSON.parse(val).byteSize);\n      }\n      // check whether the cache is full\n      if (await this.isCacheFull(item.byteSize)) {\n        const validKeys = await this.clearInvalidAndGetRemainingKeys();\n        if (await this.isCacheFull(item.byteSize)) {\n          const sizeToPop = await this.sizeToPop(item.byteSize);\n          await this.popOutItems(validKeys, sizeToPop);\n        }\n      }\n      // put item in the cache\n      return this.setCacheItem(prefixedKey, item);\n    } catch (e) {\n      logger.warn(`setItem failed! ${e}`);\n    }\n  }\n  /**\n   * Get item from cache. It will return null if item doesn’t exist or it has been expired.\n   * If you specified callback function in the options,\n   * then the function will be executed if no such item in the cache\n   * and finally put the return value into cache.\n   * Please make sure the callback function will return the value you want to put into the cache.\n   * The cache will abort output a warning:\n   * If the key is invalid\n   * If error happened with AsyncStorage\n   *\n   * @param {String} key - the key of the item\n   * @param {Object} [options] - the options of callback function\n   *\n   * @return {Promise} - return a promise resolves to be the value of the item\n   */\n  async getItem(key, options) {\n    logger.debug(`Get item: key is ${key} with options ${options}`);\n    let cached;\n    if (!key || key === currentSizeKey) {\n      logger.warn(`Invalid key: should not be empty or reserved key: '${currentSizeKey}'`);\n      return null;\n    }\n    const prefixedKey = `${this.config.keyPrefix}${key}`;\n    try {\n      cached = await this.getStorage().getItem(prefixedKey);\n      if (cached != null) {\n        if (await this.isExpired(prefixedKey)) {\n          // if expired, remove that item and return null\n          await this.removeCacheItem(prefixedKey, JSON.parse(cached).byteSize);\n        } else {\n          // if not expired, update its visitedTime and return the value\n          const item = await this.updateVisitedTime(JSON.parse(cached), prefixedKey);\n          return item.data;\n        }\n      }\n      if (options?.callback) {\n        const val = options.callback();\n        if (val !== null) {\n          await this.setItem(key, val, options);\n        }\n        return val;\n      }\n      return null;\n    } catch (e) {\n      logger.warn(`getItem failed! ${e}`);\n      return null;\n    }\n  }\n  /**\n   * remove item from the cache\n   * The cache will abort output a warning:\n   * If error happened with AsyncStorage\n   * @param {String} key - the key of the item\n   * @return {Promise}\n   */\n  async removeItem(key) {\n    logger.debug(`Remove item: key is ${key}`);\n    if (!key || key === currentSizeKey) {\n      logger.warn(`Invalid key: should not be empty or reserved key: '${currentSizeKey}'`);\n      return;\n    }\n    const prefixedKey = `${this.config.keyPrefix}${key}`;\n    try {\n      const val = await this.getStorage().getItem(prefixedKey);\n      if (val) {\n        await this.removeCacheItem(prefixedKey, JSON.parse(val).byteSize);\n      }\n    } catch (e) {\n      logger.warn(`removeItem failed! ${e}`);\n    }\n  }\n  /**\n   * Return all the keys owned by this cache.\n   * Will return an empty array if error occurred.\n   *\n   * @return {Promise}\n   */\n  async getAllKeys() {\n    try {\n      return await this.getAllCacheKeys();\n    } catch (e) {\n      logger.warn(`getAllkeys failed! ${e}`);\n      return [];\n    }\n  }\n  getStorage() {\n    return this.keyValueStorage;\n  }\n  /**\n   * check whether item is expired\n   *\n   * @param key - the key of the item\n   *\n   * @return true if the item is expired.\n   */\n  async isExpired(key) {\n    const text = await this.getStorage().getItem(key);\n    assert(text !== null, CacheErrorCode.NoCacheItem, `Key: ${key}`);\n    const item = JSON.parse(text);\n    if (getCurrentTime() >= item.expires) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * delete item from cache\n   *\n   * @param prefixedKey - the key of the item\n   * @param size - optional, the byte size of the item\n   */\n  async removeCacheItem(prefixedKey, size) {\n    const item = await this.getStorage().getItem(prefixedKey);\n    assert(item !== null, CacheErrorCode.NoCacheItem, `Key: ${prefixedKey}`);\n    const itemSize = size ?? JSON.parse(item).byteSize;\n    // first try to update the current size of the cache\n    await this.decreaseCurrentSizeInBytes(itemSize);\n    // try to remove the item from cache\n    try {\n      await this.getStorage().removeItem(prefixedKey);\n    } catch (removeItemError) {\n      // if some error happened, we need to rollback the current size\n      await this.increaseCurrentSizeInBytes(itemSize);\n      logger.error(`Failed to remove item: ${removeItemError}`);\n    }\n  }\n  /**\n   * produce a JSON object with meta-data and data value\n   * @param value - the value of the item\n   * @param options - optional, the specified meta-data\n   *\n   * @return - the item which has the meta-data and the value\n   */\n  fillCacheItem(key, value, options) {\n    const item = {\n      key,\n      data: value,\n      timestamp: getCurrentTime(),\n      visitedTime: getCurrentTime(),\n      priority: options.priority ?? 0,\n      expires: options.expires ?? 0,\n      type: typeof value,\n      byteSize: 0\n    };\n    // calculate byte size\n    item.byteSize = getByteLength(JSON.stringify(item));\n    // re-calculate using cache item with updated byteSize property\n    item.byteSize = getByteLength(JSON.stringify(item));\n    return item;\n  }\n  sanitizeConfig() {\n    if (this.config.itemMaxSize > this.config.capacityInBytes) {\n      logger.error('Invalid parameter: itemMaxSize. It should be smaller than capacityInBytes. Setting back to default.');\n      this.config.itemMaxSize = defaultConfig.itemMaxSize;\n    }\n    if (this.config.defaultPriority > 5 || this.config.defaultPriority < 1) {\n      logger.error('Invalid parameter: defaultPriority. It should be between 1 and 5. Setting back to default.');\n      this.config.defaultPriority = defaultConfig.defaultPriority;\n    }\n    if (Number(this.config.warningThreshold) > 1 || Number(this.config.warningThreshold) < 0) {\n      logger.error('Invalid parameter: warningThreshold. It should be between 0 and 1. Setting back to default.');\n      this.config.warningThreshold = defaultConfig.warningThreshold;\n    }\n    // Set 5MB limit\n    const cacheLimit = 5 * 1024 * 1024;\n    if (this.config.capacityInBytes > cacheLimit) {\n      logger.error('Cache Capacity should be less than 5MB. Setting back to default. Setting back to default.');\n      this.config.capacityInBytes = defaultConfig.capacityInBytes;\n    }\n  }\n  /**\n   * increase current size of the cache\n   *\n   * @param amount - the amount of the cache szie which need to be increased\n   */\n  async increaseCurrentSizeInBytes(amount) {\n    const size = await this.getCurrentCacheSize();\n    await this.getStorage().setItem(getCurrentSizeKey(this.config.keyPrefix), (size + amount).toString());\n  }\n  /**\n   * decrease current size of the cache\n   *\n   * @param amount - the amount of the cache size which needs to be decreased\n   */\n  async decreaseCurrentSizeInBytes(amount) {\n    const size = await this.getCurrentCacheSize();\n    await this.getStorage().setItem(getCurrentSizeKey(this.config.keyPrefix), (size - amount).toString());\n  }\n  /**\n   * update the visited time if item has been visited\n   *\n   * @param item - the item which need to be updated\n   * @param prefixedKey - the key of the item\n   *\n   * @return the updated item\n   */\n  async updateVisitedTime(item, prefixedKey) {\n    item.visitedTime = getCurrentTime();\n    await this.getStorage().setItem(prefixedKey, JSON.stringify(item));\n    return item;\n  }\n  /**\n   * put item into cache\n   *\n   * @param prefixedKey - the key of the item\n   * @param itemData - the value of the item\n   * @param itemSizeInBytes - the byte size of the item\n   */\n  async setCacheItem(prefixedKey, item) {\n    // first try to update the current size of the cache.\n    await this.increaseCurrentSizeInBytes(item.byteSize);\n    // try to add the item into cache\n    try {\n      await this.getStorage().setItem(prefixedKey, JSON.stringify(item));\n    } catch (setItemErr) {\n      // if some error happened, we need to rollback the current size\n      await this.decreaseCurrentSizeInBytes(item.byteSize);\n      logger.error(`Failed to set item ${setItemErr}`);\n    }\n  }\n  /**\n   * total space needed when poping out items\n   *\n   * @param itemSize\n   *\n   * @return total space needed\n   */\n  async sizeToPop(itemSize) {\n    const cur = await this.getCurrentCacheSize();\n    const spaceItemNeed = cur + itemSize - this.config.capacityInBytes;\n    const cacheThresholdSpace = (1 - this.config.warningThreshold) * this.config.capacityInBytes;\n    return spaceItemNeed > cacheThresholdSpace ? spaceItemNeed : cacheThresholdSpace;\n  }\n  /**\n   * see whether cache is full\n   *\n   * @param itemSize\n   *\n   * @return true if cache is full\n   */\n  async isCacheFull(itemSize) {\n    const cur = await this.getCurrentCacheSize();\n    return itemSize + cur > this.config.capacityInBytes;\n  }\n  /**\n   * get all the items we have, sort them by their priority,\n   * if priority is same, sort them by their last visited time\n   * pop out items from the low priority (5 is the lowest)\n   * @private\n   * @param keys - all the keys in this cache\n   * @param sizeToPop - the total size of the items which needed to be poped out\n   */\n  async popOutItems(keys, sizeToPop) {\n    const items = [];\n    let remainedSize = sizeToPop;\n    for (let i = 0; i < keys.length; i += 1) {\n      const val = await this.getStorage().getItem(keys[i]);\n      if (val != null) {\n        const item = JSON.parse(val);\n        items.push(item);\n      }\n    }\n    // first compare priority\n    // then compare visited time\n    items.sort((a, b) => {\n      if (a.priority > b.priority) {\n        return -1;\n      } else if (a.priority < b.priority) {\n        return 1;\n      } else {\n        if (a.visitedTime < b.visitedTime) {\n          return -1;\n        } else return 1;\n      }\n    });\n    for (let i = 0; i < items.length; i += 1) {\n      // pop out items until we have enough room for new item\n      await this.removeCacheItem(items[i].key, items[i].byteSize);\n      remainedSize -= items[i].byteSize;\n      if (remainedSize <= 0) {\n        return;\n      }\n    }\n  }\n  /**\n   * Scan the storage and combine the following operations for efficiency\n   *   1. Clear out all expired keys owned by this cache, not including the size key.\n   *   2. Return the remaining keys.\n   *\n   * @return The remaining valid keys\n   */\n  async clearInvalidAndGetRemainingKeys() {\n    const remainingKeys = [];\n    const keys = await this.getAllCacheKeys({\n      omitSizeKey: true\n    });\n    for (const key of keys) {\n      if (await this.isExpired(key)) {\n        await this.removeCacheItem(key);\n      } else {\n        remainingKeys.push(key);\n      }\n    }\n    return remainingKeys;\n  }\n  /**\n   * clear the entire cache\n   * The cache will abort and output a warning if error occurs\n   * @return {Promise}\n   */\n  async clear() {\n    logger.debug(`Clear Cache`);\n    try {\n      const keys = await this.getAllKeys();\n      for (const key of keys) {\n        await this.getStorage().removeItem(key);\n      }\n    } catch (e) {\n      logger.warn(`clear failed! ${e}`);\n    }\n  }\n}\nexport { StorageCacheCommon };","map":{"version":3,"names":["logger","ConsoleLogger","StorageCacheCommon","constructor","config","keyValueStorage","defaultConfig","sanitizeConfig","getModuleName","configure","keyPrefix","warn","getCurrentCacheSize","size","getStorage","getItem","getCurrentSizeKey","setItem","Number","key","value","options","debug","currentSizeKey","cacheItemOptions","priority","undefined","defaultPriority","expires","defaultTTL","getCurrentTime","prefixedKey","item","fillCacheItem","byteSize","itemMaxSize","val","removeCacheItem","JSON","parse","isCacheFull","validKeys","clearInvalidAndGetRemainingKeys","sizeToPop","popOutItems","setCacheItem","e","cached","isExpired","updateVisitedTime","data","callback","removeItem","getAllKeys","getAllCacheKeys","text","assert","CacheErrorCode","NoCacheItem","itemSize","decreaseCurrentSizeInBytes","removeItemError","increaseCurrentSizeInBytes","error","timestamp","visitedTime","type","getByteLength","stringify","capacityInBytes","warningThreshold","cacheLimit","amount","toString","setItemErr","cur","spaceItemNeed","cacheThresholdSpace","keys","items","remainedSize","i","length","push","sort","a","b","remainingKeys","omitSizeKey","clear"],"sources":["E:\\CSC-PROJECT\\amplify-react-app\\node_modules\\@aws-amplify\\core\\src\\Cache\\StorageCacheCommon.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ConsoleLogger } from '../Logger';\nimport { currentSizeKey, defaultConfig } from './constants';\nimport { getCurrentSizeKey, getCurrentTime, getByteLength } from './utils';\nimport { assert, CacheErrorCode } from './utils/errorHelpers';\nconst logger = new ConsoleLogger('StorageCache');\n/**\n * Initialization of the cache\n *\n */\nexport class StorageCacheCommon {\n    /**\n     * Initialize the cache\n     *\n     * @param config - Custom configuration for this instance.\n     */\n    constructor({ config, keyValueStorage, }) {\n        this.config = {\n            ...defaultConfig,\n            ...config,\n        };\n        this.keyValueStorage = keyValueStorage;\n        this.sanitizeConfig();\n    }\n    getModuleName() {\n        return 'Cache';\n    }\n    /**\n     * Set custom configuration for the cache instance.\n     *\n     * @param config - customized configuration (without keyPrefix, which can't be changed)\n     *\n     * @return - the current configuration\n     */\n    configure(config) {\n        if (config) {\n            if (config.keyPrefix) {\n                logger.warn('keyPrefix can not be re-configured on an existing Cache instance.');\n            }\n            this.config = {\n                ...this.config,\n                ...config,\n            };\n        }\n        this.sanitizeConfig();\n        return this.config;\n    }\n    /**\n     * return the current size of the cache\n     * @return {Promise}\n     */\n    async getCurrentCacheSize() {\n        let size = await this.getStorage().getItem(getCurrentSizeKey(this.config.keyPrefix));\n        if (!size) {\n            await this.getStorage().setItem(getCurrentSizeKey(this.config.keyPrefix), '0');\n            size = '0';\n        }\n        return Number(size);\n    }\n    /**\n     * Set item into cache. You can put number, string, boolean or object.\n     * The cache will first check whether has the same key.\n     * If it has, it will delete the old item and then put the new item in\n     * The cache will pop out items if it is full\n     * You can specify the cache item options. The cache will abort and output a warning:\n     * If the key is invalid\n     * If the size of the item exceeds itemMaxSize.\n     * If the value is undefined\n     * If incorrect cache item configuration\n     * If error happened with browser storage\n     *\n     * @param {String} key - the key of the item\n     * @param {Object} value - the value of the item\n     * @param {Object} [options] - optional, the specified meta-data\n     *\n     * @return {Promise}\n     */\n    async setItem(key, value, options) {\n        logger.debug(`Set item: key is ${key}, value is ${value} with options: ${options}`);\n        if (!key || key === currentSizeKey) {\n            logger.warn(`Invalid key: should not be empty or reserved key: '${currentSizeKey}'`);\n            return;\n        }\n        if (typeof value === 'undefined') {\n            logger.warn(`The value of item should not be undefined!`);\n            return;\n        }\n        const cacheItemOptions = {\n            priority: options?.priority !== undefined\n                ? options.priority\n                : this.config.defaultPriority,\n            expires: options?.expires !== undefined\n                ? options.expires\n                : this.config.defaultTTL + getCurrentTime(),\n        };\n        if (cacheItemOptions.priority < 1 || cacheItemOptions.priority > 5) {\n            logger.warn(`Invalid parameter: priority due to out or range. It should be within 1 and 5.`);\n            return;\n        }\n        const prefixedKey = `${this.config.keyPrefix}${key}`;\n        const item = this.fillCacheItem(prefixedKey, value, cacheItemOptions);\n        // check whether this item is too big;\n        if (item.byteSize > this.config.itemMaxSize) {\n            logger.warn(`Item with key: ${key} you are trying to put into is too big!`);\n            return;\n        }\n        try {\n            // first look into the storage, if it exists, delete it.\n            const val = await this.getStorage().getItem(prefixedKey);\n            if (val) {\n                await this.removeCacheItem(prefixedKey, JSON.parse(val).byteSize);\n            }\n            // check whether the cache is full\n            if (await this.isCacheFull(item.byteSize)) {\n                const validKeys = await this.clearInvalidAndGetRemainingKeys();\n                if (await this.isCacheFull(item.byteSize)) {\n                    const sizeToPop = await this.sizeToPop(item.byteSize);\n                    await this.popOutItems(validKeys, sizeToPop);\n                }\n            }\n            // put item in the cache\n            return this.setCacheItem(prefixedKey, item);\n        }\n        catch (e) {\n            logger.warn(`setItem failed! ${e}`);\n        }\n    }\n    /**\n     * Get item from cache. It will return null if item doesn’t exist or it has been expired.\n     * If you specified callback function in the options,\n     * then the function will be executed if no such item in the cache\n     * and finally put the return value into cache.\n     * Please make sure the callback function will return the value you want to put into the cache.\n     * The cache will abort output a warning:\n     * If the key is invalid\n     * If error happened with AsyncStorage\n     *\n     * @param {String} key - the key of the item\n     * @param {Object} [options] - the options of callback function\n     *\n     * @return {Promise} - return a promise resolves to be the value of the item\n     */\n    async getItem(key, options) {\n        logger.debug(`Get item: key is ${key} with options ${options}`);\n        let cached;\n        if (!key || key === currentSizeKey) {\n            logger.warn(`Invalid key: should not be empty or reserved key: '${currentSizeKey}'`);\n            return null;\n        }\n        const prefixedKey = `${this.config.keyPrefix}${key}`;\n        try {\n            cached = await this.getStorage().getItem(prefixedKey);\n            if (cached != null) {\n                if (await this.isExpired(prefixedKey)) {\n                    // if expired, remove that item and return null\n                    await this.removeCacheItem(prefixedKey, JSON.parse(cached).byteSize);\n                }\n                else {\n                    // if not expired, update its visitedTime and return the value\n                    const item = await this.updateVisitedTime(JSON.parse(cached), prefixedKey);\n                    return item.data;\n                }\n            }\n            if (options?.callback) {\n                const val = options.callback();\n                if (val !== null) {\n                    await this.setItem(key, val, options);\n                }\n                return val;\n            }\n            return null;\n        }\n        catch (e) {\n            logger.warn(`getItem failed! ${e}`);\n            return null;\n        }\n    }\n    /**\n     * remove item from the cache\n     * The cache will abort output a warning:\n     * If error happened with AsyncStorage\n     * @param {String} key - the key of the item\n     * @return {Promise}\n     */\n    async removeItem(key) {\n        logger.debug(`Remove item: key is ${key}`);\n        if (!key || key === currentSizeKey) {\n            logger.warn(`Invalid key: should not be empty or reserved key: '${currentSizeKey}'`);\n            return;\n        }\n        const prefixedKey = `${this.config.keyPrefix}${key}`;\n        try {\n            const val = await this.getStorage().getItem(prefixedKey);\n            if (val) {\n                await this.removeCacheItem(prefixedKey, JSON.parse(val).byteSize);\n            }\n        }\n        catch (e) {\n            logger.warn(`removeItem failed! ${e}`);\n        }\n    }\n    /**\n     * Return all the keys owned by this cache.\n     * Will return an empty array if error occurred.\n     *\n     * @return {Promise}\n     */\n    async getAllKeys() {\n        try {\n            return await this.getAllCacheKeys();\n        }\n        catch (e) {\n            logger.warn(`getAllkeys failed! ${e}`);\n            return [];\n        }\n    }\n    getStorage() {\n        return this.keyValueStorage;\n    }\n    /**\n     * check whether item is expired\n     *\n     * @param key - the key of the item\n     *\n     * @return true if the item is expired.\n     */\n    async isExpired(key) {\n        const text = await this.getStorage().getItem(key);\n        assert(text !== null, CacheErrorCode.NoCacheItem, `Key: ${key}`);\n        const item = JSON.parse(text);\n        if (getCurrentTime() >= item.expires) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * delete item from cache\n     *\n     * @param prefixedKey - the key of the item\n     * @param size - optional, the byte size of the item\n     */\n    async removeCacheItem(prefixedKey, size) {\n        const item = await this.getStorage().getItem(prefixedKey);\n        assert(item !== null, CacheErrorCode.NoCacheItem, `Key: ${prefixedKey}`);\n        const itemSize = size ?? JSON.parse(item).byteSize;\n        // first try to update the current size of the cache\n        await this.decreaseCurrentSizeInBytes(itemSize);\n        // try to remove the item from cache\n        try {\n            await this.getStorage().removeItem(prefixedKey);\n        }\n        catch (removeItemError) {\n            // if some error happened, we need to rollback the current size\n            await this.increaseCurrentSizeInBytes(itemSize);\n            logger.error(`Failed to remove item: ${removeItemError}`);\n        }\n    }\n    /**\n     * produce a JSON object with meta-data and data value\n     * @param value - the value of the item\n     * @param options - optional, the specified meta-data\n     *\n     * @return - the item which has the meta-data and the value\n     */\n    fillCacheItem(key, value, options) {\n        const item = {\n            key,\n            data: value,\n            timestamp: getCurrentTime(),\n            visitedTime: getCurrentTime(),\n            priority: options.priority ?? 0,\n            expires: options.expires ?? 0,\n            type: typeof value,\n            byteSize: 0,\n        };\n        // calculate byte size\n        item.byteSize = getByteLength(JSON.stringify(item));\n        // re-calculate using cache item with updated byteSize property\n        item.byteSize = getByteLength(JSON.stringify(item));\n        return item;\n    }\n    sanitizeConfig() {\n        if (this.config.itemMaxSize > this.config.capacityInBytes) {\n            logger.error('Invalid parameter: itemMaxSize. It should be smaller than capacityInBytes. Setting back to default.');\n            this.config.itemMaxSize = defaultConfig.itemMaxSize;\n        }\n        if (this.config.defaultPriority > 5 || this.config.defaultPriority < 1) {\n            logger.error('Invalid parameter: defaultPriority. It should be between 1 and 5. Setting back to default.');\n            this.config.defaultPriority = defaultConfig.defaultPriority;\n        }\n        if (Number(this.config.warningThreshold) > 1 ||\n            Number(this.config.warningThreshold) < 0) {\n            logger.error('Invalid parameter: warningThreshold. It should be between 0 and 1. Setting back to default.');\n            this.config.warningThreshold = defaultConfig.warningThreshold;\n        }\n        // Set 5MB limit\n        const cacheLimit = 5 * 1024 * 1024;\n        if (this.config.capacityInBytes > cacheLimit) {\n            logger.error('Cache Capacity should be less than 5MB. Setting back to default. Setting back to default.');\n            this.config.capacityInBytes = defaultConfig.capacityInBytes;\n        }\n    }\n    /**\n     * increase current size of the cache\n     *\n     * @param amount - the amount of the cache szie which need to be increased\n     */\n    async increaseCurrentSizeInBytes(amount) {\n        const size = await this.getCurrentCacheSize();\n        await this.getStorage().setItem(getCurrentSizeKey(this.config.keyPrefix), (size + amount).toString());\n    }\n    /**\n     * decrease current size of the cache\n     *\n     * @param amount - the amount of the cache size which needs to be decreased\n     */\n    async decreaseCurrentSizeInBytes(amount) {\n        const size = await this.getCurrentCacheSize();\n        await this.getStorage().setItem(getCurrentSizeKey(this.config.keyPrefix), (size - amount).toString());\n    }\n    /**\n     * update the visited time if item has been visited\n     *\n     * @param item - the item which need to be updated\n     * @param prefixedKey - the key of the item\n     *\n     * @return the updated item\n     */\n    async updateVisitedTime(item, prefixedKey) {\n        item.visitedTime = getCurrentTime();\n        await this.getStorage().setItem(prefixedKey, JSON.stringify(item));\n        return item;\n    }\n    /**\n     * put item into cache\n     *\n     * @param prefixedKey - the key of the item\n     * @param itemData - the value of the item\n     * @param itemSizeInBytes - the byte size of the item\n     */\n    async setCacheItem(prefixedKey, item) {\n        // first try to update the current size of the cache.\n        await this.increaseCurrentSizeInBytes(item.byteSize);\n        // try to add the item into cache\n        try {\n            await this.getStorage().setItem(prefixedKey, JSON.stringify(item));\n        }\n        catch (setItemErr) {\n            // if some error happened, we need to rollback the current size\n            await this.decreaseCurrentSizeInBytes(item.byteSize);\n            logger.error(`Failed to set item ${setItemErr}`);\n        }\n    }\n    /**\n     * total space needed when poping out items\n     *\n     * @param itemSize\n     *\n     * @return total space needed\n     */\n    async sizeToPop(itemSize) {\n        const cur = await this.getCurrentCacheSize();\n        const spaceItemNeed = cur + itemSize - this.config.capacityInBytes;\n        const cacheThresholdSpace = (1 - this.config.warningThreshold) * this.config.capacityInBytes;\n        return spaceItemNeed > cacheThresholdSpace\n            ? spaceItemNeed\n            : cacheThresholdSpace;\n    }\n    /**\n     * see whether cache is full\n     *\n     * @param itemSize\n     *\n     * @return true if cache is full\n     */\n    async isCacheFull(itemSize) {\n        const cur = await this.getCurrentCacheSize();\n        return itemSize + cur > this.config.capacityInBytes;\n    }\n    /**\n     * get all the items we have, sort them by their priority,\n     * if priority is same, sort them by their last visited time\n     * pop out items from the low priority (5 is the lowest)\n     * @private\n     * @param keys - all the keys in this cache\n     * @param sizeToPop - the total size of the items which needed to be poped out\n     */\n    async popOutItems(keys, sizeToPop) {\n        const items = [];\n        let remainedSize = sizeToPop;\n        for (let i = 0; i < keys.length; i += 1) {\n            const val = await this.getStorage().getItem(keys[i]);\n            if (val != null) {\n                const item = JSON.parse(val);\n                items.push(item);\n            }\n        }\n        // first compare priority\n        // then compare visited time\n        items.sort((a, b) => {\n            if (a.priority > b.priority) {\n                return -1;\n            }\n            else if (a.priority < b.priority) {\n                return 1;\n            }\n            else {\n                if (a.visitedTime < b.visitedTime) {\n                    return -1;\n                }\n                else\n                    return 1;\n            }\n        });\n        for (let i = 0; i < items.length; i += 1) {\n            // pop out items until we have enough room for new item\n            await this.removeCacheItem(items[i].key, items[i].byteSize);\n            remainedSize -= items[i].byteSize;\n            if (remainedSize <= 0) {\n                return;\n            }\n        }\n    }\n    /**\n     * Scan the storage and combine the following operations for efficiency\n     *   1. Clear out all expired keys owned by this cache, not including the size key.\n     *   2. Return the remaining keys.\n     *\n     * @return The remaining valid keys\n     */\n    async clearInvalidAndGetRemainingKeys() {\n        const remainingKeys = [];\n        const keys = await this.getAllCacheKeys({\n            omitSizeKey: true,\n        });\n        for (const key of keys) {\n            if (await this.isExpired(key)) {\n                await this.removeCacheItem(key);\n            }\n            else {\n                remainingKeys.push(key);\n            }\n        }\n        return remainingKeys;\n    }\n    /**\n     * clear the entire cache\n     * The cache will abort and output a warning if error occurs\n     * @return {Promise}\n     */\n    async clear() {\n        logger.debug(`Clear Cache`);\n        try {\n            const keys = await this.getAllKeys();\n            for (const key of keys) {\n                await this.getStorage().removeItem(key);\n            }\n        }\n        catch (e) {\n            logger.warn(`clear failed! ${e}`);\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}