{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst DEFAULT_RETRY_ATTEMPTS = 3;\n/**\n * Retry middleware\n */\nconst retryMiddlewareFactory = ({\n  maxAttempts = DEFAULT_RETRY_ATTEMPTS,\n  retryDecider,\n  computeDelay,\n  abortSignal\n}) => {\n  if (maxAttempts < 1) {\n    throw new Error('maxAttempts must be greater than 0');\n  }\n  return (next, context) => async function retryMiddleware(request) {\n    let error;\n    let attemptsCount = context.attemptsCount ?? 0;\n    let response;\n    // When retry is not needed or max attempts is reached, either error or response will be set. This function handles either cases.\n    const handleTerminalErrorOrResponse = () => {\n      if (response) {\n        addOrIncrementMetadataAttempts(response, attemptsCount);\n        return response;\n      } else {\n        addOrIncrementMetadataAttempts(error, attemptsCount);\n        throw error;\n      }\n    };\n    while (!abortSignal?.aborted && attemptsCount < maxAttempts) {\n      try {\n        response = await next(request);\n        error = undefined;\n      } catch (e) {\n        error = e;\n        response = undefined;\n      }\n      // context.attemptsCount may be updated after calling next handler which may retry the request by itself.\n      attemptsCount = (context.attemptsCount ?? 0) > attemptsCount ? context.attemptsCount ?? 0 : attemptsCount + 1;\n      context.attemptsCount = attemptsCount;\n      if (await retryDecider(response, error)) {\n        if (!abortSignal?.aborted && attemptsCount < maxAttempts) {\n          // prevent sleep for last attempt or cancelled request;\n          const delay = computeDelay(attemptsCount);\n          await cancellableSleep(delay, abortSignal);\n        }\n        continue;\n      } else {\n        return handleTerminalErrorOrResponse();\n      }\n    }\n    if (abortSignal?.aborted) {\n      throw new Error('Request aborted.');\n    } else {\n      return handleTerminalErrorOrResponse();\n    }\n  };\n};\nconst cancellableSleep = (timeoutMs, abortSignal) => {\n  if (abortSignal?.aborted) {\n    return Promise.resolve();\n  }\n  let timeoutId;\n  let sleepPromiseResolveFn;\n  const sleepPromise = new Promise(resolve => {\n    sleepPromiseResolveFn = resolve;\n    timeoutId = setTimeout(resolve, timeoutMs);\n  });\n  abortSignal?.addEventListener('abort', function cancelSleep(_) {\n    clearTimeout(timeoutId);\n    abortSignal?.removeEventListener('abort', cancelSleep);\n    sleepPromiseResolveFn();\n  });\n  return sleepPromise;\n};\nconst addOrIncrementMetadataAttempts = (nextHandlerOutput, attempts) => {\n  if (Object.prototype.toString.call(nextHandlerOutput) !== '[object Object]') {\n    return;\n  }\n  nextHandlerOutput.$metadata = {\n    ...(nextHandlerOutput.$metadata ?? {}),\n    attempts\n  };\n};\nexport { retryMiddlewareFactory };","map":{"version":3,"names":["DEFAULT_RETRY_ATTEMPTS","retryMiddlewareFactory","maxAttempts","retryDecider","computeDelay","abortSignal","Error","next","context","retryMiddleware","request","error","attemptsCount","response","handleTerminalErrorOrResponse","addOrIncrementMetadataAttempts","aborted","undefined","e","delay","cancellableSleep","timeoutMs","Promise","resolve","timeoutId","sleepPromiseResolveFn","sleepPromise","setTimeout","addEventListener","cancelSleep","_","clearTimeout","removeEventListener","nextHandlerOutput","attempts","Object","prototype","toString","call","$metadata"],"sources":["E:\\CSC-PROJECT\\amplify-react-app\\node_modules\\@aws-amplify\\core\\src\\clients\\middleware\\retry\\middleware.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst DEFAULT_RETRY_ATTEMPTS = 3;\n/**\n * Retry middleware\n */\nexport const retryMiddlewareFactory = ({ maxAttempts = DEFAULT_RETRY_ATTEMPTS, retryDecider, computeDelay, abortSignal, }) => {\n    if (maxAttempts < 1) {\n        throw new Error('maxAttempts must be greater than 0');\n    }\n    return (next, context) => async function retryMiddleware(request) {\n        let error;\n        let attemptsCount = context.attemptsCount ?? 0;\n        let response;\n        // When retry is not needed or max attempts is reached, either error or response will be set. This function handles either cases.\n        const handleTerminalErrorOrResponse = () => {\n            if (response) {\n                addOrIncrementMetadataAttempts(response, attemptsCount);\n                return response;\n            }\n            else {\n                addOrIncrementMetadataAttempts(error, attemptsCount);\n                throw error;\n            }\n        };\n        while (!abortSignal?.aborted && attemptsCount < maxAttempts) {\n            try {\n                response = await next(request);\n                error = undefined;\n            }\n            catch (e) {\n                error = e;\n                response = undefined;\n            }\n            // context.attemptsCount may be updated after calling next handler which may retry the request by itself.\n            attemptsCount =\n                (context.attemptsCount ?? 0) > attemptsCount\n                    ? context.attemptsCount ?? 0\n                    : attemptsCount + 1;\n            context.attemptsCount = attemptsCount;\n            if (await retryDecider(response, error)) {\n                if (!abortSignal?.aborted && attemptsCount < maxAttempts) {\n                    // prevent sleep for last attempt or cancelled request;\n                    const delay = computeDelay(attemptsCount);\n                    await cancellableSleep(delay, abortSignal);\n                }\n                continue;\n            }\n            else {\n                return handleTerminalErrorOrResponse();\n            }\n        }\n        if (abortSignal?.aborted) {\n            throw new Error('Request aborted.');\n        }\n        else {\n            return handleTerminalErrorOrResponse();\n        }\n    };\n};\nconst cancellableSleep = (timeoutMs, abortSignal) => {\n    if (abortSignal?.aborted) {\n        return Promise.resolve();\n    }\n    let timeoutId;\n    let sleepPromiseResolveFn;\n    const sleepPromise = new Promise(resolve => {\n        sleepPromiseResolveFn = resolve;\n        timeoutId = setTimeout(resolve, timeoutMs);\n    });\n    abortSignal?.addEventListener('abort', function cancelSleep(_) {\n        clearTimeout(timeoutId);\n        abortSignal?.removeEventListener('abort', cancelSleep);\n        sleepPromiseResolveFn();\n    });\n    return sleepPromise;\n};\nconst addOrIncrementMetadataAttempts = (nextHandlerOutput, attempts) => {\n    if (Object.prototype.toString.call(nextHandlerOutput) !== '[object Object]') {\n        return;\n    }\n    nextHandlerOutput.$metadata = {\n        ...(nextHandlerOutput.$metadata ?? {}),\n        attempts,\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}